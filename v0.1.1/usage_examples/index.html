<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage and Examples · BroadLineRegions.jl</title><meta name="title" content="Usage and Examples · BroadLineRegions.jl"/><meta property="og:title" content="Usage and Examples · BroadLineRegions.jl"/><meta property="twitter:title" content="Usage and Examples · BroadLineRegions.jl"/><meta name="description" content="Documentation for BroadLineRegions.jl."/><meta property="og:description" content="Documentation for BroadLineRegions.jl."/><meta property="twitter:description" content="Documentation for BroadLineRegions.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BroadLineRegions.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage and Examples</a><ul class="internal"><li><a class="tocitem" href="#Reproducing-the-line-profile-and-transfer-function-shown-in-[CM96](https://ui.adsabs.harvard.edu/abs/1996ApJ...466..704C/abstract)"><span>Reproducing the line profile and transfer function shown in CM96</span></a></li><li><a class="tocitem" href="#Reproducing-sample-cloud-model-results-from-[Pancoast2014](https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract)"><span>Reproducing sample cloud model results from Pancoast+2014</span></a></li><li><a class="tocitem" href="#Reproducing-the-line-and-phase-profiles-shown-in-[Long2023](https://dx.doi.org/10.3847/1538-4357/ace4bb)"><span>Reproducing the line and phase profiles shown in Long+2023</span></a></li><li><a class="tocitem" href="#Reproducing-the-combined-model-line-and-delay-profiles-shown-in-Long2025"><span>Reproducing the combined model line and delay profiles shown in Long+2025</span></a></li><li><a class="tocitem" href="#Defining-your-own-custom-models"><span>Defining your own custom models</span></a></li><li><a class="tocitem" href="#Additional-(selected)-helpful-tools-from-the-[API](@ref)-not-described-above"><span>Additional (selected) helpful tools from the API not described above</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage and Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage and Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kirklong/BroadLineRegions.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kirklong/BroadLineRegions.jl/blob/main/docs/src/usage_examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage-and-Examples"><a class="docs-heading-anchor" href="#Usage-and-Examples">Usage and Examples</a><a id="Usage-and-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-and-Examples" title="Permalink"></a></h1><p>This guide explores a few more complicated tasks one might wish to use this code for. </p><ul><li><a href="#Reproducing-the-line-profile-and-transfer-function-shown-in-[CM96](https://ui.adsabs.harvard.edu/abs/1996ApJ...466..704C/abstract)">Reproducing the line profile and transfer function shown in CM96</a></li><li><a href="#Reproducing-sample-cloud-model-results-from-[Pancoast2014](https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract)">Reproducing sample cloud model results from Pancoast+2014</a></li><li><a href="#Reproducing-the-line-and-phase-profiles-shown-in-[Long2023](https://dx.doi.org/10.3847/1538-4357/ace4bb)">Reproducing the line and phase profiles shown in Long+2023</a></li><li><a href="#Reproducing-the-combined-model-line-and-delay-profiles-shown-in-Long2025">Reproducing the combined model line and delay profiles shown in Long+2025</a></li><li><a href="#Defining-your-own-custom-models">Defining your own custom models</a></li><li><a href="#Additional-(selected)-helpful-tools-from-the-[API](@ref)-not-described-above">Additional (selected) helpful tools from the API not described above</a></li></ul><h2 id="Reproducing-the-line-profile-and-transfer-function-shown-in-[CM96](https://ui.adsabs.harvard.edu/abs/1996ApJ...466..704C/abstract)"><a class="docs-heading-anchor" href="#Reproducing-the-line-profile-and-transfer-function-shown-in-[CM96](https://ui.adsabs.harvard.edu/abs/1996ApJ...466..704C/abstract)">Reproducing the line profile and transfer function shown in <a href="https://ui.adsabs.harvard.edu/abs/1996ApJ...466..704C/abstract">CM96</a></a><a id="Reproducing-the-line-profile-and-transfer-function-shown-in-[CM96](https://ui.adsabs.harvard.edu/abs/1996ApJ...466..704C/abstract)-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducing-the-line-profile-and-transfer-function-shown-in-[CM96](https://ui.adsabs.harvard.edu/abs/1996ApJ...466..704C/abstract)" title="Permalink"></a></h2><p>CM96 showed that disk-wind models of the BLR could produce single-peaked line profiles, and as part of their results they generated a hypothetical 2D transfer function for a disk-wind BLR as applied to NGC 5548. We can reproduce such a map with just a few lines of code using <code>BroadLineRegions.jl</code>. </p><div class="admonition is-info" id="Note-9969307494540cea"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9969307494540cea" title="Permalink"></a></header><div class="admonition-body"><p><code>BroadLineRegions.jl</code> exports itself as both <code>BroadLineRegions</code> <em>and</em> the shorter <code>BLR</code>. We will use the shorter <code>BLR</code> throughout these examples but know that <code>BLR</code> is equivalent to <code>BroadLineRegions</code> should you prefer the longer version.</p></div></div><p>First, let&#39;s define the model using <a href="../api/#BroadLineRegions.DiskWindModel-NTuple{4, Float64}"><code>DiskWindModel</code></a>: </p><pre><code class="language-julia hljs">using BroadLineRegions
mCM96 = BLR.DiskWindModel(3000.,100.,1.,75/180*π,
        nr=2048,nϕ=1024,scale=:log,f1=1.0,f2=1.0,f3=0.0,f4=0.0,
        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,τ=5.0,reflect=false)</code></pre><p>We use the parameters from CM96 for <span>$\bar{r} = 3000\rm{r_s}$</span>, <span>$r_{\rm{fac}} = 10^2$</span>, <span>$\alpha = 1$</span>, and <span>$i = 75^{\circ}$</span>. CM96 considered the case of radial and Keplerian shear only, so we turn these gradients on by setting <span>$f_1 = 1$</span> and <span>$f_2 = 1$</span> (radial and Keplerian shear, respectively) and turn off the remaining velocity gradients by setting <span>$f_3 = 0$</span> and <span>$f_4 = 0$</span>. </p><p>To have a well sampled model grid we pick <code>nr=5096</code> and <code>nϕ=1024</code> with <code>scale=:log</code>, which will result in the returned model object having 5096 &quot;rings&quot; in our circular camera aperture with each ring holding 1024 grid cells evenly divided in <span>$\\phi$</span> space. </p><p>While this is the default, for the sake of this demonstration we also set <a href="../api/#BroadLineRegions.DiskWindIntensity-Tuple{}"><code>I=BLR.DiskWindIntensity</code></a> to explicitly tell the model to use the intensity formulation first proposed in CM96 (and using the &quot;f&quot; parameter language introduced in Long+2023). We also tell the model to calculate the velocities according to the built in function <a href="../api/#BroadLineRegions.vCircularDisk-Tuple{}"><code>BLR.vCircularDisk</code></a>, which simply calculates the projected line of sight velocity as <span>$v = \sqrt{\frac{\rm{r_s}}{2r}}\sin i \sin\phi$</span>. </p><p>Finally, while not required, we set <code>τ = 5.0</code> as we want our disk to be optically thick and <code>reflect = false</code> as we do not want to move any points from the back to the front. </p><p>Now that we have a model, let&#39;s get the line profile and store it in our model:</p><pre><code class="language-julia hljs">p = BLR.getProfile(mCM96,:line,bins=101) #get the line profile using 101 bins in velocity-space, otherwise using default params
BLR.setProfile!(mCM96,p) #store the line profile in our model structure</code></pre><p>We can do a quick visualization with the built-in <a href="../api/#BroadLineRegions.profile!-Tuple"><code>profile</code></a> macro:</p><pre><code class="language-julia hljs">BLR.profile(mCM96) #plot all profiles stored in model object, here we only have set :line so only :line will be plotted</code></pre><p>Which should return a plot like this (left panel, right panel is Figure 2 in CM96):</p><p><img src="../LPCM96_quickComparison.png" alt="result of BLR.profile"/></p><p>Note that the y-axis units are arbitrary and the x-axis is in units of velocity [<span>$c$</span>], not <span>$\lambda$</span> as published in Fig 2 of <a href="https://articles.adsabs.harvard.edu/pdf/1996ApJ...466..704C">CM96</a>, but the shape clearly matches their result that the line profile for such a model should be single-peaked. This is also showing only the full model line profile (thei solid line), not the data or other models. We could reproduce their plot exactly by rescaling our flux and converting from velocity-space to wavelength space as well as plotting the data and a model line profile with azimuthally isotropic emission, but we will leave that as an exercise for the motivated reader...</p><p>It is similarly easy to use <code>BroadLineRegions.jl</code> to generate transfer functions for any user-defined model. In looking at Figure 4 of <a href="https://articles.adsabs.harvard.edu/pdf/1996ApJ...466..704C">CM96</a> we see that their y-axis (delays) spans 0-20 days and the x-axis (projected velocity) -12-12 (<span>$10^8$</span> <span>$\rm{cm}$</span> <span>$\rm{s}^-1$</span>). To match our model result to theirs, we first need to convert our units of <span>$\rm{r_s}$</span> to the more physical unit of days. CM96 used <span>$M_{\rm{NGC5548}} \approx 10^8 \rm{M_{\odot}}$</span>, which means we can calculate the conversion factor as:</p><pre><code class="language-julia hljs">M = 1e8*2e30 #kg
rs = 2*M*6.67e-11/9e16 #2GM/c^2
rsDay = rs/3e8/3600/24 #days</code></pre><p>We only need to obtain the transfer function <span>$\Psi$</span> over the range shown in CM96, so let&#39;s define the <code>tEdges</code> and <code>vEdges</code> we want to use to match their result and then generate the transfer function:</p><pre><code class="language-julia hljs">tEdges = collect(range(0.0,stop=20.0/rsDay,length=101)) #will generate 100 bins, convert 20 days upper limit to units of rs
vEdges = collect(range(-0.04,stop=0.04,length=101)) #0.04c ~12*1e8 cm/s
Ψ = BLR.getΨ(mCM96,vEdges,tEdges) #obtain transfer function with our supplied bin edges </code></pre><p>Note that in Fig. 4 of <a href="https://articles.adsabs.harvard.edu/pdf/1996ApJ...466..704C">CM96</a> the edges between the colors are sharp, indicating that they used discrete bins in their image to better showcase structure. While these levels are not explicitly supplied in the paper, we can make a good guess that they are somewhat evenly spaced logarithmic bins. To transform our <span>$\Psi$</span> to match their binning, we can do something like: </p><pre><code class="language-julia hljs">function getΨMatch(ΨBinned,levels=[-0.4*i for i=0:11]) #generate constant log10 bins of Ψ
    #fills intervals that are closed at the top;
    #that is, for regions z1 and z2 the filled region is z1 &lt; Z &lt;= z2&quot;

    logΨ = log10.(ΨBinned)
    res = zeros(size(logΨ))
    mask = (logΨ .&lt;= levels[2]) .&amp; (logΨ .&gt;= levels[1])
    res[mask] .= (levels[1]+levels[2])/2
    for i=2:length(levels)-1
        mask = (logΨ .&lt; levels[i]) .&amp; (logΨ .&gt;= levels[i+1])
        res[mask] .= (levels[i]+levels[i+1])/2
    end
    mask = (logΨ .&lt; levels[end])
    res[mask] = logΨ[mask]
    return res
end
ΨDiscrete = getΨMatch(Ψ./maximum(Ψ)) #normalize and generate discrete bins</code></pre><p>All that&#39;s left to do now is visualize the result, which we will do with the <code>heatmap</code> function from Julia&#39;s <code>Plots.jl</code>:</p><pre><code class="language-julia hljs">using Plots

heatmap(vEdges.*3e10/1e8,tEdges.*rsDay,ΨDiscrete&#39;,
    ylims=(0,20),xlims=(-12,12),clims=(-4.4,0.0),cbar=false,
    xlabel=&quot;v (10⁸ cm/s)&quot;,ylabel=&quot;τ (days)&quot;,minorticks=true,
    tickdirection=:out,widen=false,size=(500,500))</code></pre><p>Which should return something like this (left plot, right plot is Fig 4. in CM96):</p><p><img src="../CM96_Psi_quickComparison.png" alt="2D Ψ map"/></p><p>While our binning is a little off/coarser than in CM96, this is clearly a pretty good match for a quick and dirty calculation. </p><p>A few final notes: </p><ol><li>Note that when plotting we use <code>ΨDiscrete&#39;</code> because heatmap expects the shape of the image variable to be flipped from how <code>BroadLineRegions.jl</code> calculates it (the shape of <code>Ψ</code> when returned is (number of velocity bins, number of t bins)). </li><li>If you wanted to generate just the 1D response function as shown in CM96 Figure 5, <code>BroadLineRegions.jl</code> has syntax for that too: <code>tCenters, Ψt = BLR.getΨt(mCM96,101,10/rsDay)</code>. </li></ol><h2 id="Reproducing-sample-cloud-model-results-from-[Pancoast2014](https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract)"><a class="docs-heading-anchor" href="#Reproducing-sample-cloud-model-results-from-[Pancoast2014](https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract)">Reproducing sample cloud model results from <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract">Pancoast+2014</a></a><a id="Reproducing-sample-cloud-model-results-from-[Pancoast2014](https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract)-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducing-sample-cloud-model-results-from-[Pancoast2014](https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract)" title="Permalink"></a></h2><p>We can also generate &quot;cloud&quot;/thick-disk models of the BLR similar to <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract">Pancoast+2014</a> easily with <code>BroadLineRegions.jl</code>. In this section we will reproduce part of Figure 4 in <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract">Pancoast+2014</a>, which shows five different model BLRs and their 1D transfer functions with the following parameters: </p><table><tr><th style="text-align: center">parameter</th><th style="text-align: center">model 1</th><th style="text-align: center">model 2</th></tr><tr><td style="text-align: center"><span>$r_{\rm{mean}}$</span> [days]</td><td style="text-align: center">4.0</td><td style="text-align: center">4.0</td></tr><tr><td style="text-align: center"><span>$F$</span></td><td style="text-align: center">0.25</td><td style="text-align: center">0.25</td></tr><tr><td style="text-align: center"><span>$\beta$</span></td><td style="text-align: center">1.0</td><td style="text-align: center">0.8</td></tr><tr><td style="text-align: center"><span>$\theta_o$</span> [deg]</td><td style="text-align: center">40</td><td style="text-align: center">30</td></tr><tr><td style="text-align: center"><span>$i$</span> [deg]</td><td style="text-align: center">20</td><td style="text-align: center">20</td></tr><tr><td style="text-align: center"><span>$\kappa$</span></td><td style="text-align: center">-0.4</td><td style="text-align: center">-0.4</td></tr><tr><td style="text-align: center"><span>$\gamma$</span></td><td style="text-align: center">5.0</td><td style="text-align: center">5.0</td></tr><tr><td style="text-align: center"><span>$\xi$</span></td><td style="text-align: center">0.3</td><td style="text-align: center">0.1</td></tr><tr><td style="text-align: center"><span>$f_{\rm{ellipse}}$</span></td><td style="text-align: center">0.0</td><td style="text-align: center">1.0</td></tr><tr><td style="text-align: center"><span>$f_{\rm{flow}}$</span></td><td style="text-align: center">0.0</td><td style="text-align: center">-</td></tr><tr><td style="text-align: center"><span>$\theta_e$</span> [deg]</td><td style="text-align: center">0.0</td><td style="text-align: center">-</td></tr><tr><td style="text-align: center"><span>$\sigma_{\rm{turb}}$</span></td><td style="text-align: center">0.0</td><td style="text-align: center">0.0</td></tr></table><p>First, we initialize model structs for both of these cases:</p><pre><code class="language-julia hljs">M = 10^(6.5)*2e30 #kg, from Pancoast+2014
rs = 2*6.67e-11*M/9e16 #2GM/c^2, m
rsDay = rs/3e8/3600/24 #days^C #days -- model expects μ in units of rₛ
nClouds = 100_000 #small number of clouds just for demonstration
mP1 = BLR.cloudModel(nClouds,μ=4/rsDay,F=0.25,β=1.0,θₒ=40/180*π,i=20/180*π,
        κ=-0.4,γ=5.0,ξ=0.3,fEllipse=0.0,fFlow=0.0,θₑ=0.0,σₜ=0.0,
        σρc=0.0,σΘᵣ=0.0,σΘc=0.0,σρᵣ=0.0,
        I=BLR.cloudIntensity,v=BLR.vCloudTurbulentEllipticalFlow,τ=0.0)
mP2 = BLR.cloudModel(nClouds,μ=4/rsDay,F=0.25,β=0.8,θₒ=30/180*π,i=20/180*π,
        κ=-0.4,γ=5.0,ξ=0.1,fEllipse=1.0,σₜ=0.0,
        fFlow=0.0,θₑ=0.0,σρc=0.0,σΘᵣ=0.0,σΘc=0.0,σρᵣ=0.0,
        I=BLR.cloudIntensity,v=BLR.vCloudTurbulentEllipticalFlow,τ=0.0)</code></pre><p>Where the first argument passed to <a href="../api/#BroadLineRegions.cloudModel-Tuple{Int64}"><code>cloudModel</code></a> is the number of clouds to generate (here we use a relatively small number just for demonstration purposes), and the keyword arguments supplied mostly correspond to the values in the table above and are fully described in <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract">Pancoast+2014</a>. The extra keyword arguments set to 0 but not in the table are options not used in this calculation, and the final line specifies that we would like the intensity calculated with the <a href="../api/#BroadLineRegions.cloudIntensity-Tuple{}"><code>cloudIntensity</code></a> function, the velocities calculated with <a href="../api/#BroadLineRegions.vCloudTurbulentEllipticalFlow-Tuple{}"><code>vCloudTurbulentEllipticalFlow</code></a>, and that the optical depth of the cloud is 0.</p><p>To compare to Figure 4 in <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract">Pancoast+2014</a> we can again generate transfer functions for both models:</p><pre><code class="language-julia hljs">using Plots

vEdges = collect(range(-0.015,stop=0.015,length=51)) #Δλ/λ ~ v/c
tEdges = collect(range(0.0,stop=20.0/rsDay,length=51))
Ψ1 = BLR.getΨ(mP1,vEdges,tEdges)
Ψ2 = BLR.getΨ(mP2,vEdges,tEdges)
p1 = heatmap(vEdges.*3e5,tEdges.*rsDay,(Ψ1&#39;./maximum(Ψ1)).^(1/2),ylims=(0,20),cbar=false,
    xlabel=&quot;Δv (km/s)&quot;,ylabel=&quot;Lag (days)&quot;,minorticks=true,tickdirection=:out,
    widen=false,size=(500,500),guidefontsize=18,tickfontsize=16)
p2 = heatmap(vEdges.*3e5,tEdges.*rsDay,(Ψ2&#39;./maximum(Ψ2)).^(1/2),ylims=(0,20),cbar=false,
    xlabel=&quot;Δv (km/s)&quot;,ylabel=&quot;Lag (days)&quot;,minorticks=true,tickdirection=:out,
    widen=false,size=(500,500),guidefontsize=18,tickfontsize=16)</code></pre><p>Which should produce something like the left column of plots in the comparison below (top plot = <code>p1</code> and bottom = <code>p2</code>):</p><p><img src="../P14_Psi_quickComparison.png" alt="2D cloud Ψ maps"/></p><p>Note that again we are just trying to roughly match the color scale by eye, but the general shape and morphology looks good.</p><p>We can also quickly visualize the geometry of the system from any angle (i.e. to compare to the rightmost panel of Fig. 4 in <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract">Pancoast+2014</a>) using the built-in <a href="../api/#BroadLineRegions.plot3d-Tuple"><code>plot3d</code></a> macro:</p><pre><code class="language-julia hljs">BLR.plot3d(mP1,:I,cam=(10,10)) #visualize the system with points colored by their intensity with a camera at 10 deg azimuth and altitude</code></pre><p>Iterating this over a wide variety of camera angles one can produce fun 3D visualizations of the BLR models like the gifs below:</p><table><tr><th style="text-align: center">model 1</th><th style="text-align: center">model 2</th></tr><tr><td style="text-align: center"><img src="../mP1.gif" alt="gif of model 1 geometry"/></td><td style="text-align: center"><img src="../mP2.gif" alt="gif of model 2 geometry"/></td></tr></table><p>Comparing to the stills in Figure 4 of <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract">Pancoast+2014</a> again shows good agreement (note that in generating this animation the number of clouds was set to be just 2,000 to better show the structure/agreement with Pancoast+2014). </p><h2 id="Reproducing-the-line-and-phase-profiles-shown-in-[Long2023](https://dx.doi.org/10.3847/1538-4357/ace4bb)"><a class="docs-heading-anchor" href="#Reproducing-the-line-and-phase-profiles-shown-in-[Long2023](https://dx.doi.org/10.3847/1538-4357/ace4bb)">Reproducing the line and phase profiles shown in <a href="https://dx.doi.org/10.3847/1538-4357/ace4bb">Long+2023</a></a><a id="Reproducing-the-line-and-phase-profiles-shown-in-[Long2023](https://dx.doi.org/10.3847/1538-4357/ace4bb)-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducing-the-line-and-phase-profiles-shown-in-[Long2023](https://dx.doi.org/10.3847/1538-4357/ace4bb)" title="Permalink"></a></h2><p>While reverberation mapping has historically been the primary way to constrain the properties of the BLR, advances in interferometry have recently allowed for the BLR to be directly &quot;imaged&quot; by <a href="https://ui.adsabs.harvard.edu/abs/2019Msngr.178...20A/abstract">GRAVITY on the VLTI</a>, up to <a href="https://www.nature.com/articles/s41586-024-07053-4"><span>$z\sim 2.5$</span></a>! </p><p>Here we will demonstrate how to generate line and <em>phase</em> profiles for model BLRs, reproducing the results shown in the left panel in Figure 2 of <a href="https://dx.doi.org/10.3847/1538-4357/ace4bb">Long+2023</a> in the process. To start, we define disk-wind model objects for each case shown in the figure: </p><pre><code class="language-julia hljs">mLAll = BLR.DiskWindModel(8e3,45.,1.,45/180*π,nr=2048,nϕ=1024,
        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=1.0,f2=1.0,
        f3=1.0,f4=1.0,τ=5.,reflect=false)
mLf1 = BLR.DiskWindModel(8e3,45.,1.,45/180*π,nr=2048,nϕ=1024,
        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=1.0,f2=0.0,
        f3=0.0,f4=0.0,τ=5.,reflect=false)
mLf2 = BLR.DiskWindModel(8e3,45.,1.,45/180*π,nr=2048,nϕ=1024,
        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=0.0,f2=1.0,
        f3=0.0,f4=0.0,τ=5.,reflect=false)
mLf3 = BLR.DiskWindModel(8e3,45.,1.,45/180*π,nr=2048,nϕ=1024,
        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=0.0,f2=0.0,
        f3=1.0,f4=0.0,τ=5.,reflect=false)
mLf4 = BLR.DiskWindModel(8e3,45.,1.,45/180*π,nr=2048,nϕ=1024,
        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=0.0,f2=0.0,
        f3=0.0,f4=1.0,τ=5.,reflect=false)</code></pre><p>Setting the values in <a href="../api/#BroadLineRegions.DiskWindModel-NTuple{4, Float64}"><code>DiskWindModel</code></a> to approximately match those in the paper. </p><p>We can then generate the line profiles for each just as we did in the CM96 example above:</p><pre><code class="nohighlight hljs">LPAll = BLR.getProfile(mLAll,:line,bins=101,centered=true)
LPf1 = BLR.getProfile(mLf1,:line,bins=101,centered=true)
LPf2 = BLR.getProfile(mLf2,:line,bins=101,centered=true)
LPf3 = BLR.getProfile(mLf3,:line,bins=101,centered=true)
LPf4 = BLR.getProfile(mLf4,:line,bins=101,centered=true)</code></pre><p>Note that this time we don&#39;t store the profiles in their respective models (although we could!) because we are going to plot all of the models on top of each other by hand. </p><p>To generate the average phase profile we need to pass a few bits of additional information to the <a href="#BroadLineRegions.phase"><code>phase</code></a> function. As the documenation there shows, we must supply the U-V baseline information (in units of <span>$\rm{M\lambda}$</span>), the position angle, and the angular scale size of the BLR. Using the published information in the paper we can set these quantities and generate the average phase profiles like so:</p><pre><code class="language-julia hljs">#&quot;off&quot; axis U-V baselines as in Gravity+2019, Long+2023
U = [-14.942664391893409, -29.796334354450384, -14.76368897621181, -7.76620715016356, -11.58052554955926, -4.073062007808528, -14.957054767646966, -28.352905965208993, -13.459074151241555, -13.168981507518257, -23.464313904842403, -10.912122036718138] #Mλ
V = [-15.04195936592504, -36.26778925081391, -21.229760064196043, -14.479367253742678, -35.24862063439095, -20.773150186942956, -14.816925731069297, -35.8588243819711, -21.043799197907198, -15.401140293812933, -37.58326121804998, -21.630778375611328] #Mλ
BLRAng = 2*8e7*2e33*6.67e-8/9e20/548/3.09e24 #rₛ in radians for BLR distance of 548 Mpc
PA = 300/180*π #rad

phaseAll = BLR.getProfile(mLAll,:phase,bins=101,centered=true,U=U,V=V,PA=PA,BLRAng=BLRAng)
phasef1 = BLR.getProfile(mLf1,:phase,bins=101,centered=true,U=U,V=V,PA=PA,BLRAng=BLRAng)
phasef2 = BLR.getProfile(mLf2,:phase,bins=101,centered=true,U=U,V=V,PA=PA,BLRAng=BLRAng)
phasef3 = BLR.getProfile(mLf3,:phase,bins=101,centered=true,U=U,V=V,PA=PA,BLRAng=BLRAng)
phasef4 = BLR.getProfile(mLf4,:phase,bins=101,centered=true,U=U,V=V,PA=PA,BLRAng=BLRAng)</code></pre><p>We can then plot the line and phase profiles for all the models and compare to Figure 2 in <a href="https://dx.doi.org/10.3847/1538-4357/ace4bb">Long+2023</a>:</p><pre><code class="language-julia hljs">using Plots

pLP = plot(title=&quot;line profiles&quot;,xlabel=&quot;Δv [Mm/s]&quot;,ylabel=&quot;flux [normalized]&quot;) #initialize LP plot
LPList = [LPAll,LPf1,LPf2,LPf3,LPf4]
norm = maximum(LPAll.binSums)
for p in LPList
    pLP = plot!(p.binCenters.*3e2,p.binSums./norm,label=&quot;&quot;,lw=2) #label them in the phase plot only
end

pPhase = plot(title=&quot;average phase profiles&quot;,xlabel=&quot;Δv [Mm/s]&quot;,ylabel=&quot;Δϕ [deg]&quot;,legend=:topleft) #initialize phase plot
LPList = [phaseAll,phasef1,phasef2,phasef3,phasef4]
labels = [&quot;All terms equal&quot;,&quot;f₁ only&quot;,&quot;f₂ only&quot;,&quot;f₃ only&quot;,&quot;f₄ only&quot;]
for (l,p) in zip(labels,LPList)
    pPhase = plot!(p.binCenters.*3e2,p.binSums.*180/π,label=l,lw=2)
end

plot(pLP,pPhase,layout=@layout([a;b]),size=(500,800),margins=5*Plots.Measures.mm)</code></pre><p>Which should return something similar to the left panel below. Compared to the original plot (right panel) we can again see that we have reproduced the result quite well. </p><p><img src="../Long2023_phase_line_quickComparison.png" alt="line and phase profiles for disk-wind models"/></p><p>A few final notes: </p><ol><li>When setting the position angle, we rotated from the approximate value given in <a href="https://dx.doi.org/10.3847/1538-4357/ace4bb">Long+2023</a> by <span>$\pi$</span> because in older versions of this code the disk&#39;s velocity structure was flipped, which means the left and right photocenters on the sky are by default on the opposite sides in the new versions of the code than they were in the old ones. This is fixed easily by just rotating a little extra!</li><li>Minor differences in the amplitude/structure of the phase profiles are due to not picking and choosing only the baselines that are &quot;off&quot; axis, see <a href="https://dx.doi.org/10.3847/1538-4357/ace4bb">Long+2023</a> for details.</li></ol><h2 id="Reproducing-the-combined-model-line-and-delay-profiles-shown-in-Long2025"><a class="docs-heading-anchor" href="#Reproducing-the-combined-model-line-and-delay-profiles-shown-in-Long2025">Reproducing the combined model line and delay profiles shown in Long+2025</a><a id="Reproducing-the-combined-model-line-and-delay-profiles-shown-in-Long2025-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducing-the-combined-model-line-and-delay-profiles-shown-in-Long2025" title="Permalink"></a></h2><p>The real utility of <code>BroadLineRegions.jl</code> is not in its ability to model certain prescriptions for the BLR, but instead the ability to <em>flexibly combine</em> them. To demonstrate this we will reproduce the hybrid disk + cloud model line and delay profiles shown in Figure 4 of Long+2025. As described in the paper, this model is a combination of a Pancoast style &quot;cloud&quot; model and a simple azimuthally isotropic disk model with a bit of radial inflow. We can generate both submodels and then combine them with simple syntax: </p><pre><code class="language-julia hljs">mDisk = BLR.DiskWindModel(300.,40.,1.0,30/180*π,nr=512,nϕ=1024,f1=0.0,f2=0.0,f3=0.0,f4=1.0,
        reflect=false,I=BLR.DiskWindIntensity,τ=5.,v=BLR.vCircularRadialDisk,vᵣFrac=0.33,inflow=true) 
        #setting only f4 = azimuthally isotropic disk, 2/3 Keplerian 1/3 inflow velocity field
mClouds = BLR.cloudModel(1_000_000; I=BLR.cloudIntensity, v=BLR.vCloudTurbulentEllipticalFlow, i=30/180*π, 
        θₒ=15/180*π, β=1.25, F=0.5, μ=300., κ=0.4, ξ=0.6, γ=0.65, fEllipse=0.8, fFlow=0.0, θₑ=35/180*π, σρᵣ=0.2, 
        σρc=0.04, σΘᵣ=0.4, σΘc=0.1, σₜ=0.05,τ=0.0)
        #parameters from Long+2025

#in Long+2025 the ratio between the sum of intensity values in the cloud submodel and disk submodel is ~1:1
#so we need to rescale one of the models to ensure this is true
#note that scaling things this way is arbitrary -- a more physical way would be to specify the ratio of I*ΔA
IDisk = BLR.getVariable(mDisk,:I)
IClouds = BLR.getVariable(mClouds,:I)
ratio = sum(IDisk[.!isnan.(IDisk)])/sum(IClouds[.!isnan.(IClouds)])
for ring in mDisk.rings
    ring.I .*= 1/ratio
end

mCombined = mDisk+mClouds #all we have to do to combine models is &quot;add&quot; them!</code></pre><p>We can again easily generate profiles for both the combined model and the submodels. This time we will generate line and delay profiles for each component and the combined model to compare to Figure 4 of Long+2025:</p><pre><code class="language-julia hljs">#get line profiles for each model
LPCombined = BLR.getProfile(mCombined,:line,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)
LPDisk = BLR.getProfile(mDisk,:line,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)
LPClouds = BLR.getProfile(mClouds,:line,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)
#get delay profiles for each model
DPCombined = BLR.getProfile(mCombined,:delay,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)
DPDisk = BLR.getProfile(mDisk,:delay,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)
DPClouds = BLR.getProfile(mClouds,:delay,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)

#plot the results
using Plots
pLP = plot(LPCombined.binCenters.*3e5,LPCombined.binSums./maximum(LPCombined.binSums),c=:purple,lw=2,label=&quot;&quot;)
pLP = plot!(LPDisk.binCenters.*3e5,LPDisk.binSums./maximum(LPDisk.binSums),c=:dodgerblue,lw=2,label=&quot;&quot;,ls=:dash)
pLP = plot!(LPClouds.binCenters.*3e5,LPClouds.binSums./maximum(LPClouds.binSums),c=:crimson,lw=2,label=&quot;&quot;,ls=:dash)
pLP = plot!(xlabel=&quot;v [km/s]&quot;,ylabel=&quot;flux [normalized]&quot;,title=&quot;line profiles&quot;,xticks=[0.5e4*i for i=-2:2],xlims=(-1e4,1e4))

M = 1.7e8*2e30 #kg
rs = 2*6.67e-11*M/9e16 #2GM/c^2, m
rsDay = rs/3e8/3600/24 #days
pDP = plot(DPCombined.binCenters.*3e5,DPCombined.binSums.*rsDay,c=:purple,lw=2,label=&quot;combined&quot;)
pDP = plot!(DPDisk.binCenters.*3e5,DPDisk.binSums.*rsDay,c=:dodgerblue,lw=2,label=&quot;thin-disk component&quot;,ls=:dash)
pDP = plot!(DPClouds.binCenters.*3e5,DPClouds.binSums.*rsDay,c=:crimson,lw=2,label=&quot;cloud component&quot;,ls=:dash)
pDP = plot!(xlabel=&quot;v [km/s]&quot;,ylabel=&quot;delay [days]&quot;,title=&quot;delay profiles&quot;,xticks=[0.5e4*i for i=-2:2],
    foreground_color_legend=nothing,background_color_legend=nothing,xlims=(-1e4,1e4),ylims=(0,16))

plot(pLP,pDP,layout=@layout([a;b]),size=(500,800),tickdirection=:out,minorticks=true,margins=5*Plots.Measures.mm)</code></pre><p>Which should produce something like the left panel in the comparison below (with the right panel being the result published in Long+2025):</p><p><img src="../Long2025_line_delay_combined_quickComparison.png" alt="line and delay profiles for combined + submodels"/></p><p>Note that there is some inherent randomness in the clouds, and you can improve the smoothness of the profiles by increasing the number of model points if you so desire, but we&#39;ve reproduced the main features in the plot just fine even at this lower resolution.</p><p>You can of course visualize your combined models with the same standard plotting recipes shown earlier to generate fun animations like the one below showcasing the intensity, delay, and velocity structure of this combined model: </p><p><img src="../mCombined.gif" alt="Sample combined model animation for parameters in Long+2025"/></p><h2 id="Defining-your-own-custom-models"><a class="docs-heading-anchor" href="#Defining-your-own-custom-models">Defining your own custom models</a><a id="Defining-your-own-custom-models-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-your-own-custom-models" title="Permalink"></a></h2><p><code>BroadLineRegions.jl</code> makes it easy to define your own models, either by modifying one of the existing classes of models or starting entirely from scratch. </p><p>For example, say you wanted to use the <a href="../api/#BroadLineRegions.cloudModel-Tuple{Int64}"><code>cloudModel</code></a> as a base but wanted the intensities to be completely randomized. You could define your own custom intensity function and pass that to the <a href="../api/#BroadLineRegions.cloudModel-Tuple{Int64}"><code>cloudModel</code></a> constructor like so:</p><pre><code class="language-julia hljs">myCustomIntensityFunction(;_...) = rand() #note the _... to handle unsupported kwargs that may be passed to your intensity function
myCloudModel = BLR.cloudModel(100,I=myCustomIntensityFunction) #100 clouds with random intensities using defaults for all other parameters</code></pre><p>It is possible to pass custom intensity, velocity, response, and optical depth functions to either <a href="../api/#BroadLineRegions.cloudModel-Tuple{Int64}"><code>cloudModel</code></a> or <a href="../api/#BroadLineRegions.DiskWindModel-NTuple{4, Float64}"><code>DiskWindModel</code></a>.</p><p>If you already have some precalculated result for any of the above quantities which you would like to use in your model, you can also pass that array to the model constructor so long as it matches the size requirements (i.e. if you have 100 clouds must pass an array of 100 intensities). </p><p>You can also modify models after creation, as shown in the Long+2025 example above where we rescaled the total intensity in the disk submodel. </p><div class="admonition is-info" id="Note-4ec1876298b7bf3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4ec1876298b7bf3" title="Permalink"></a></header><div class="admonition-body"><p>The <a href="../api/#BroadLineRegions.model"><code>model</code></a> and <a href="../api/#BroadLineRegions.ring"><code>ring</code></a> structs are <em>mutable</em>, meaning any operations you perform on them overwrite previous values. This includes submodels in larger models, i.e. if you overwrite a field in a combined model the submodel struct will also be mutated. </p></div></div><p>Of course you are not limited to using <code>BroadLineRegions.jl</code>&#39;s predefined model constructors. The most general way to make a <a href="../api/#BroadLineRegions.model"><code>model</code></a> is to simply pass an array of <a href="../api/#BroadLineRegions.ring"><code>ring</code></a> structs, a dictionary of <a href="../api/#BroadLineRegions.profile"><code>profile</code></a> structs, a <a href="../api/#BroadLineRegions.camera"><code>camera</code></a> struct, and an array of submodel start indices. </p><p>Each <a href="../api/#BroadLineRegions.ring"><code>ring</code></a> represents a &quot;ring&quot; on a &quot;camera&quot; observing the BLR, and this mutable structs holds all the interesting quantities about the BLR we might wish to model. The <a href="../api/#BroadLineRegions.camera"><code>camera</code></a> struct holds the <span>$\alpha$</span> (x) and <span>$\beta$</span> (y) camera coordinates for all points in the model, and in each corresponding <a href="../api/#BroadLineRegions.ring"><code>ring</code></a> we must supply the relevant physical information on the BLR associated with that camera pixel. See the full documentation of <a href="../api/#BroadLineRegions.ring"><code>ring</code></a> for all available options, but at a minimum in each ring we must define <span>$\phi$</span>, <span>$I$</span>, <span>$v$</span>, <span>$i$</span> and <span>$r$</span> for the BLR. </p><p>For example, say we were looking top down at an imaginary BLR whose bespoke structure happened to spell out the friendly message &quot;don&#39;t panic&quot; with random intensities and rotating out of the page. We could implement this custom BLR like:</p><pre><code class="language-julia hljs"># Generate a matrix with 1s for letter pixels and 0s for background
function fortytwo() #Full disclosure: Claude helped write this one...
    mat = zeros(Int, 8, 53)
    
    # d
    mat[1,1] = 1; mat[1,2] = 1; mat[1,3] = 1; mat[1,4] = 1
    mat[2,1] = 1;                                      mat[2,5] = 1
    mat[3,1] = 1;                                      mat[3,5] = 1
    mat[4,1] = 1;                                      mat[4,5] = 1
    mat[5,1] = 1;                                      mat[5,5] = 1
    mat[6,1] = 1;                                      mat[6,5] = 1
    mat[7,1] = 1;                                      mat[7,5] = 1
    mat[8,1] = 1; mat[8,2] = 1; mat[8,3] = 1; mat[8,4] = 1
    
    # o
    mat[1,7] = 1; mat[1,8] = 1; mat[1,9] = 1; mat[1,10] = 1; mat[1,11] = 1
    mat[2,7] = 1;                                            mat[2,11] = 1
    mat[3,7] = 1;                                            mat[3,11] = 1
    mat[4,7] = 1;                                            mat[4,11] = 1
    mat[5,7] = 1;                                            mat[5,11] = 1
    mat[6,7] = 1;                                            mat[6,11] = 1
    mat[7,7] = 1;                                            mat[7,11] = 1
    mat[8,7] = 1; mat[8,8] = 1; mat[8,9] = 1; mat[8,10] = 1; mat[8,11] = 1
    
    # n
    mat[1,13] = 1;                                           mat[1,17] = 1
    mat[2,13] = 1;                                           mat[2,17] = 1
    mat[3,13] = 1; mat[3,14] = 1; mat[3,15] = 1;             mat[3,17] = 1
    mat[4,13] = 1; mat[4,14] = 1; mat[4,15] = 1; mat[4,16] = 1; mat[4,17] = 1
    mat[5,13] = 1;                               mat[5,16] = 1; mat[5,17] = 1
    mat[6,13] = 1;                                           mat[6,17] = 1
    mat[7,13] = 1;                                           mat[7,17] = 1
    mat[8,13] = 1;                                           mat[8,17] = 1
    
    # &#39; (apostrophe)
    mat[1,19] = 1
    mat[2,19] = 1
    
    # t
                   mat[1,22] = 1
                   mat[2,22] = 1
    mat[3,21] = 1; mat[3,22] = 1; mat[3,23] = 1; mat[3,24] = 1; mat[3,25] = 1
    mat[4,21] = 1; mat[4,22] = 1; mat[4,23] = 1; mat[4,24] = 1; mat[4,25] = 1
                   mat[5,22] = 1
                   mat[6,22] = 1
                   mat[7,22] = 1;                                           mat[7,25] = 1
                   mat[8,22] = 1; mat[8,22] = 1; mat[8,23] = 1; mat[8,24] = 1

    # space between t and p
    
    # p
    mat[1,29] = 1; mat[1,30] = 1; mat[1,31] = 1; mat[1,32] = 1; mat[1,33] = 1
    mat[2,29] = 1;                                           mat[2,33] = 1
    mat[3,29] = 1;                                           mat[3,33] = 1
    mat[4,29] = 1; mat[4,30] = 1; mat[4,31] = 1; mat[4,32] = 1; mat[4,33] = 1
    mat[5,29] = 1
    mat[6,29] = 1
    mat[7,29] = 1
    mat[8,29] = 1
    
    # a
    mat[1,35] = 1; mat[1,36] = 1; mat[1,37] = 1; mat[1,38] = 1; mat[1,39] = 1
    mat[2,35] = 1;                                           mat[2,39] = 1
    mat[3,35] = 1;                                           mat[3,39] = 1
    mat[4,35] = 1; mat[4,36] = 1; mat[4,37] = 1; mat[4,38] = 1; mat[4,39] = 1
    mat[5,35] = 1; mat[5,36] = 1; mat[5,37] = 1; mat[5,38] = 1; mat[5,39] = 1
    mat[6,35] = 1;                                           mat[6,39] = 1
    mat[7,35] = 1;                                           mat[7,39] = 1
    mat[8,35] = 1;                                           mat[8,39] = 1
    
    # n
    mat[1,41] = 1;                                           mat[1,45] = 1
    mat[2,41] = 1;                                           mat[2,45] = 1
    mat[3,41] = 1; mat[3,42] = 1; mat[3,43] = 1;             mat[3,45] = 1
    mat[4,41] = 1; mat[4,42] = 1; mat[4,43] = 1; mat[4,44] = 1; mat[4,45] = 1
    mat[5,41] = 1;                               mat[5,44] = 1; mat[5,45] = 1
    mat[6,41] = 1;                                           mat[6,45] = 1
    mat[7,41] = 1;                                           mat[7,45] = 1
    mat[8,41] = 1;                                           mat[8,45] = 1
    
    # i
    mat[1,47] = 1
    mat[3,47] = 1
    mat[4,47] = 1
    mat[5,47] = 1
    mat[6,47] = 1
    mat[7,47] = 1
    mat[8,47] = 1
    
    # c
    mat[1,49] = 1; mat[1,50] = 1; mat[1,51] = 1; mat[1,52] = 1; mat[1,53] = 1
    mat[2,49] = 1
    mat[3,49] = 1
    mat[4,49] = 1
    mat[5,49] = 1
    mat[6,49] = 1
    mat[7,49] = 1
    mat[8,49] = 1; mat[8,50] = 1; mat[8,51] = 1; mat[8,52] = 1; mat[8,53] = 1
    
    return mat
end

mat = reverse(fortytwo(),dims=1) #reverse top/bottom
α = zeros(sum(mat)) #camera x coordinates in units of rs
β = zeros(sum(mat)) #camera y coordinates in units of rs
αj = range(-size(mat)[2]/2,stop=size(mat)[2]/2,length=size(mat)[2])
βi = range(-size(mat)[1]/2,stop=size(mat)[1]/2,length=size(mat)[1])
counter = 0
for i=1:size(mat)[1]
    for j=1:size(mat)[2]
        if mat[i,j] != 0 #fill in camera coordinates where matrix non-empty
            counter += 1 #which point are we on?
            α[counter] = αj[j]
            β[counter] = βi[i]
        end
    end
end

cam = BLR.camera(α,β,false) #initialize the camera for the model, set raytraced flag to false

rings = Array{BLR.ring}(undef,sum(mat)) #initialize array of rings

for j=1:length(rings) #define the rings with minimum physical quantities of our model BLR
    r = √(α[j]^2+β[j]^2) #radius in physical space = camera radius for i = 0.0
    ϕ = atan(β[j],α[j]) #angle in physical space = camera ngle for i = 0.0
    i = 0.0 #inclination
    I = rand()
    v = sqrt(1/r)*sign(α[j]) #rotating in/out of the page and proportional to √1/r
    ΔA = 1.0 #rₛ²
    rings[j] = BLR.ring(r=r,ϕ=ϕ,i=i,I=I,v=v,ΔA=ΔA) #define ring with minimum physical quantities using defaults for everything else
    #note that 3d plotting will be wrong for this, as the 3D plotting routine assumes you start with point in x-y plane and then rotate into z direction
    #do things in this order if you care about 3d visualizations of your custom models (but otherwise it does not matter)
end

# Create the custom BLR model
myCustomModel = BLR.model(rings,Dict{Symbol,BLR.profile}(),cam,[1]) #no profiles (yet), only one submodel so subModelStartInds = [1] 

#visualize it
using Plots
imgI = BLR.image(myCustomModel,:I,markersize=2.,background_color=:black,cmap=cgrad([:red,:lime],[0.0,0.3,1.0]))
imgv = BLR.image(myCustomModel,:v,markersize=2.,background_color=:black,cmap=cgrad([:blue,:red],[-1.,0.,1.]))
p = BLR.getProfile(myCustomModel,:line,bins=10)
BLR.setProfile!(myCustomModel,p)
p = BLR.getProfile(myCustomModel,:r,bins=10)
BLR.setProfile!(myCustomModel,p)
p = BLR.getProfile(myCustomModel,:ϕ,bins=10)
BLR.setProfile!(myCustomModel,p)
P = BLR.profile(myCustomModel)
plot(imgI,imgv,P,layout=@layout([grid(2,1) P{0.4w}]),size=(800,400),margins=5*Plots.Measures.mm)</code></pre><p>Which produces the following plot: <img src="../custom_quick.png" alt="don&#39;t panic BLR"/></p><div class="admonition is-info" id="Note-3cca5262b58b21f5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3cca5262b58b21f5" title="Permalink"></a></header><div class="admonition-body"><p>If you want the default 3D visualizations to work correctly, define your points in the x-y plane and then rotate them into 3D space using <a href="../api/#BroadLineRegions.rotate3D"><code>rotate3D</code></a> as this is what <a href="../api/#BroadLineRegions.plot3d-Tuple"><code>plot3d</code></a> calls on points to make the 3D visualizations. This should not affect any science use case if you opt to initialize the points some other way (like in the quick example above).</p></div></div><h2 id="Additional-(selected)-helpful-tools-from-the-[API](@ref)-not-described-above"><a class="docs-heading-anchor" href="#Additional-(selected)-helpful-tools-from-the-[API](@ref)-not-described-above">Additional (selected) helpful tools from the <a href="../api/#API">API</a> not described above</a><a id="Additional-(selected)-helpful-tools-from-the-[API](@ref)-not-described-above-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-(selected)-helpful-tools-from-the-[API](@ref)-not-described-above" title="Permalink"></a></h2><p>After combining submodels, access their constituent parts by simply writing:</p><pre><code class="language-julia hljs">mCombined = m1+m2 #combine two models
m1 = mCombined[1]; m2 = mCombined[2] #get access to the submodels with indexing </code></pre><p>If you are annoyed with the output statements after things, suppress them by placing a semicolon after:</p><pre><code class="language-julia hljs">mCombined; #suppresses output</code></pre><p>Other functions: </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BroadLineRegions.getVariable" href="#BroadLineRegions.getVariable"><code>BroadLineRegions.getVariable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getVariable(m::model, variable::Union{String,Symbol,Function}; flatten=false)</code></pre><p>Retrieve elements from model object and stack them into matrices for easy manipulation.</p><p><strong>Arguments</strong></p><ul><li><code>m::model</code>: Model object to extract variables from</li><li><code>variable::Union{String,Symbol,Function}</code>: Variable to extract from model<ul><li>If <code>String</code>, will be converted to <code>Symbol</code></li><li>Must be a valid attribute of <code>model.rings</code> (e.g. <code>:I</code>, <code>:v</code>, <code>:r</code>, <code>:e</code>, <code>:i</code>, <code>:ϕ</code>) or a function that can be applied to <code>model.rings</code></li><li>Example: Keplerian disk time delays could be calculated like <code>t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))</code></li></ul></li><li><code>flatten::Bool=false</code>: If true, flatten the result to a vector</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64,}</code>: Matrix or vector of extracted variable from <code>model.rings</code>, created by stacking the output variable for each ring<ul><li>For example, if variable given is <code>:I</code>, result will have shape <code>(length(r), length(ϕ))</code> as at each <code>r</code> and <code>ϕ</code> there is a value of <code>I</code></li><li>If <code>flatten=true</code>, result will be a flattened vector</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kirklong/BroadLineRegions.jl/blob/fd61b92ee1ff105b78050bb990f84ef34cfe1e78/src/util.jl#L186-L203">source</a></section><section><div><pre><code class="language-julia hljs">getVariable(m::model, variable::Symbol; flatten=false)</code></pre><p>Retrieve model variable when specified as a <code>Symbol</code>. See main docstring for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kirklong/BroadLineRegions.jl/blob/fd61b92ee1ff105b78050bb990f84ef34cfe1e78/src/util.jl#L209-L213">source</a></section><section><div><pre><code class="language-julia hljs">getVariable(m::model, variable::Function; flatten=false)</code></pre><p>Retrieve model variable when specified as a <code>Function</code>. See main docstring for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kirklong/BroadLineRegions.jl/blob/fd61b92ee1ff105b78050bb990f84ef34cfe1e78/src/util.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BroadLineRegions.raytrace!" href="#BroadLineRegions.raytrace!"><code>BroadLineRegions.raytrace!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">raytrace!(m::model; IRatios::Union{Float64,Array{Float64,}}=1.0, 
        τCutOff::Float64=1.0, raytraceFreeClouds::Bool=false)</code></pre><p>Perform raytracing for a model, combining overlapping components along line of sight.</p><div class="admonition is-warning" id="Slow-e68989bdc57daf58"><header class="admonition-header">Slow<a class="admonition-anchor" href="#Slow-e68989bdc57daf58" title="Permalink"></a></header><div class="admonition-body"><p>This function not very performant and can take a long time to combine large models. Consider using <a href="../api/#BroadLineRegions.removeDiskObscuredClouds!"><code>removeDiskObscuredClouds!</code></a> for simple disk obscuration removal if you do not need full raytracing.</p></div></div><p>This function should be called after combining all relevant models (i.e. <code>mCombined = m1 + m2 + m3...</code>). It performs raytracing in discrete steps (no absorption, only adding intensity in chunks along  the line of sight until maximum optical depth <code>τ</code> is reached) and generates a new model object  with extraneous points removed. Note that this function will mutate the input model objects.</p><p><strong>Arguments</strong></p><ul><li><code>m::model</code>: Model to raytrace</li><li><code>IRatios::Union{Float64,Array{Float64,}}=1.0</code>: Intensity ratios for each submodel<ul><li>If <code>Float64</code>, applies to all submodels equally</li><li>If array, applies to each submodel individually (must match number of submodels)</li><li>Used when combining models with different intensity functions if they aren&#39;t properly normalized</li></ul></li><li><code>τCutOff::Float64=1.0</code>: Maximum optical depth to raytrace to (stops when <code>τ &gt; τCutOff</code>)</li><li><code>raytraceFreeClouds::Bool=false</code>: Whether to raytrace free clouds (cloud-cloud raytracing)<ul><li>If <code>false</code>, clouds are only raytraced if they overlap with a continuous model</li><li>If <code>true</code>, clouds will be checked for overlap with other clouds and raytraced accordingly</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>m::model</code>: Model with raytraced points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kirklong/BroadLineRegions.jl/blob/fd61b92ee1ff105b78050bb990f84ef34cfe1e78/src/raytrace.jl#L288-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BroadLineRegions.reset!" href="#BroadLineRegions.reset!"><code>BroadLineRegions.reset!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(m::model; profiles=true, img=false)</code></pre><p>Erase existing profiles/raytrace status.</p><p><strong>Parameters</strong></p><ul><li><code>m::model</code>: Model object to reset</li><li><code>profiles::Bool=true</code>: If true, reset profiles</li><li><code>img::Bool=false</code>: If true, reset raytracing boolean (does not change existing model but allows model to be raytraced again after combining other new models)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kirklong/BroadLineRegions.jl/blob/fd61b92ee1ff105b78050bb990f84ef34cfe1e78/src/util.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BroadLineRegions.phase" href="#BroadLineRegions.phase"><code>BroadLineRegions.phase</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phase(m::model; U, V, PA, BLRAng, returnAvg=false, offAxisInds=nothing, kwargs...)</code></pre><p>Calculate differential phase signal for a model based on specified baselines, model orientation, and BLR angular size.</p><p><strong>Arguments</strong></p><ul><li><code>m::model</code>: Model object to calculate phase for</li><li><code>U::Vector{Float64}</code>: U component of complex visibility in [Mλ]</li><li><code>V::Vector{Float64}</code>: V component of complex visibility in [Mλ]</li><li><code>PA::Float64</code>: On-sky position angle of the model in radians</li><li><code>BLRAng::Float64</code>: Characteristic size of the BLR model in radians (conversion from <span>$r_s$</span> to radians)</li><li><code>returnAvg::Bool=false</code>: If <code>true</code>, returns the average phase across all baselines</li><li><code>offAxisInds::Union{Nothing,Vector{Int}}=nothing</code>: If provided, only calculates phase for baselines at specified indices</li></ul><p><strong>Returns</strong></p><ul><li>If <code>returnAvg=true</code>: <code>Tuple{Vector{Float64},Vector{Float64},Vector{Float64}}</code> containing:<ul><li>Bin edges for velocity</li><li>Bin centers for velocity</li><li>Average differential phase (in radians)</li></ul></li><li>If <code>returnAvg=false</code>: <code>Vector{Tuple{Vector{Float64},Vector{Float64},Vector{Float64}}}</code> containing:<ul><li>For each baseline, a tuple of bin edges, bin centers, and differential phase</li></ul></li></ul><p>The differential phase is calculated by integrating the phase over the model at each velocity bin, weighted by the intensity and area of each ring element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kirklong/BroadLineRegions.jl/blob/fd61b92ee1ff105b78050bb990f84ef34cfe1e78/src/profiles.jl#L160-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BroadLineRegions.DRW" href="#BroadLineRegions.DRW"><code>BroadLineRegions.DRW</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function DRW(;t::Array{Float64}=collect(range(0,stop=100,length=1001)), μ::Float64=0.0, τ::Float64=1.0, σ::Float64=0.1)</code></pre><p>Generate a damped random walk continuum lightcurve following <a href="https://iopscience.iop.org/article/10.1088/0004-637X/721/2/1014/pdf">MacLeod+2010</a></p><p><strong>Arguments:</strong></p><ul><li><code>t::Vector{Float64}</code>`: time array that returned lightcurve will be sampled at</li><li><code>μ::Float64</code>: mean value of random walk</li><li><code>τ::Float64</code>: characteristic time scale of random walk</li><li><code>σ::Float64</code>: standard deviation of random walk</li></ul><p><strong>Returns:</strong></p><ul><li><code>C::Vector{Float64}</code>: damped random walk array corresponding to times t</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kirklong/BroadLineRegions.jl/blob/fd61b92ee1ff105b78050bb990f84ef34cfe1e78/src/lightcurve.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BroadLineRegions.syntheticLC" href="#BroadLineRegions.syntheticLC"><code>BroadLineRegions.syntheticLC</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function syntheticLC(Ct,CLC,Ψτ;tStart=0.0,normalize=false)</code></pre><p>Generate a synthetic lightcurve from a continuum lightcurve and a 1D transfer function.</p><p><strong>Arguments:</strong></p><ul><li><code>Ct::Vector{Float64}</code>: time array for the continuum lightcurve</li><li><code>CLC::Vector{Float64}</code>: continuum lightcurve values at times <code>Ct</code></li><li><code>Ψτ::Vector{Float64}</code>: transfer function values at times <code>Ct</code></li><li><code>tStart::Float64</code>: time after which the lightcurve should be normalized to zero</li><li><code>normalize::Bool</code>: whether to normalize the lightcurve to the extent of variations in the continuum</li></ul><p><strong>Returns:</strong></p><ul><li><code>Δlc::Vector{Float64}</code>: synthetic lightcurve sampled at times <code>Ct</code> with zero point ~at <code>tStart</code> and optionally normalized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kirklong/BroadLineRegions.jl/blob/fd61b92ee1ff105b78050bb990f84ef34cfe1e78/src/lightcurve.jl#L31-L42">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Sunday 29 June 2025 20:31">Sunday 29 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
