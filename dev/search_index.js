var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#BLR.DiskWindModel-NTuple{4, Float64}","page":"API","title":"BLR.DiskWindModel","text":"DiskWindModel(r̄::Float64, rFac::Float64, α::Float64, i::Float64; rot::Float64=0.0, nr::Int=128, nϕ::Int=256, scale::Symbol=:log, kwargs...)\n\nUses the model constructor to create a DiskWind model of the BLR as detailed in Long+2023 and Long+2025.\n\nParameters\n\nr̄::Float64: Mean radius of model (in terms of r_s)\nrFac::Float64: Radius factor\nα::Float64: Power-law source function scaling\ni::Float64: Inclination angle in radians\nrot::Float64=0.0: Rotation of system plane about z-axis in radians\nnr::Int=128: Number of radial bins\nnϕ::Int=256: Number of azimuthal bins\nscale::Symbol=:log: Radial binning scale (:log or :linear)\nkwargs...: Extra keyword arguments for model constructor (see examples)\n\nReturns\n\nmodel object\n\nNote\n\nSimilar to another DiskWind model constructor but here we pass r̄, rFac, and α.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.DiskWindModel-Tuple{Float64, Float64, Float64}","page":"API","title":"BLR.DiskWindModel","text":"DiskWindModel(rMin::Float64, rMax::Float64, i::Float64; nr::Int=128, nϕ::Int=256, I::Function=DiskWindIntensity, v::Function=vCircularDisk, scale::Symbol=:log, kwargs...)\n\nUses the model constructor to create a DiskWind model of the BLR as detailed in Long+2023 and Long+2025.\n\nParameters\n\nrMin::Float64: Minimum radius of model (in terms of r_s)\nrMax::Float64: Maximum radius of model (in terms of r_s)\ni::Float64: Inclination angle in radians (all rings have the same inclination)\nnr::Int=128: Number of radial bins\nnϕ::Int=256: Number of azimuthal bins\nI::Function=DiskWindIntensity: Intensity function\nv::Function=vCircularDisk: Velocity function\nscale::Symbol=:log: Radial binning scale (:log or :linear)\nkwargs...: Extra keyword arguments for I and v functions (see examples)\n\nReturns\n\nmodel object\n\nNote\n\nSimilar to other DiskWind model constructor but must explicitly pass rMin and rMax.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.addGrid!","page":"API","title":"BLR.addGrid!","text":"addGrid!(m::model, colors=nothing, nϕ::Int=64)\n\nAdd a grid to the model image plot - mostly a debugging tool to visualize grid cells of overlapping models.\n\nArguments\n\nm::model: Model object to add grid to\ncolors=nothing: Vector of colors for each submodel (if nothing, uses default colors)\nnϕ::Int=64: Number of azimuthal angles to use for the grid\n\nReturns\n\n::Plots.plot: Plot with grid added\n\n\n\n\n\n","category":"function"},{"location":"api/#BLR.binModel","page":"API","title":"BLR.binModel","text":"binModel(bins::Union{Int,Vector{Float64}}=100; m::model, yVariable::Union{String,Symbol,Function}, xVariable::Union{String,Symbol,Function}=:v, kwargs...)\nbinModel(bins::Vector{Float64}, dx::Array{Float64,}; m::model, yVariable::Union{String,Symbol,Function}, xVariable::Union{String,Symbol,Function}=:v, kwargs...)\n\nBin the model into a histogram, where each bin is the integrated value of the yVariable as a function of the xVariable.\n\nArguments\n\nm::model: Model object to bin\nyVariable::Union{String,Symbol,Function}: Variable to bin\nMust be valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nbins::Union{Int,Vector{Float64}}: Number of bins or bin edges for binning\nIf Int: Number of bins with edges equally spaced between min/max of xVariable\nIf Vector{Float64}: Specific bin edges, with number of bins = length(bins)-1\nLeft edge inclusive, right edge exclusive (except last bin which is inclusive)\nxVariable::Union{String,Symbol,Function}=:v: Variable to bin over\nMust be a valid attribute of model.rings or a function that can be applied to model.rings\ndx::Array{Float64,}: Integration element for each bin\nIf provided, used as the associated integral element\nOtherwise defaults to ΔA in each ring struct\n\nReturns\n\nTuple{Vector{Float64},Vector{Float64},Vector{Float64}}: A tuple containing:\nbinEdges: Bin edges for the xVariable of the histogram\nbinCenters: Bin centers for the xVariable\nyBinned: Binned values of the yVariables\n\n\n\n\n\n","category":"function"},{"location":"api/#BLR.binnedSum-Tuple{Array{Float64}, Array{Float64}}","page":"API","title":"BLR.binnedSum","text":"binnedSum(x::Array{Float64,}, y::Array{Float64, }; bins=100, overflow=false, centered=false, minX=nothing, maxX=nothing)\n\nBin the x and y variables into a histogram, where each bin is the sum of the y values for the corresponding x values.\n\nArguments\n\nx::Array{Float64,}: x variable to bin over\ny::Array{Float64,}: y variable to bin\nbins::Union{Int,Vector{Float64}}=100: Number of bins or bin edges for binning\nIf Int: Number of bins with edges equally spaced between min/max of x\nIf Vector{Float64}: Specific bin edges, with number of bins = length(bins)-1\nLeft edge inclusive, right edge exclusive (except last bin which is inclusive)\noverflow::Bool=false: If true, include values outside bin range in the first/last bins\ncentered::Bool=false: If true, shift bin edges to center around middle value\nminX::Union{Float64,Nothing}=nothing: Minimum value of x for binning (defaults to minimum(x))\nmaxX::Union{Float64,Nothing}=nothing: Maximum value of x for binning (defaults to maximum(x))\n\nReturns\n\nTuple{Vector{Float64},Vector{Float64},Vector{Float64}}: A tuple containing:\nbinEdges: Bin edges for the x variable\nbinCenters: Bin centers for the x variable\nresult: Binned sums of the y variable\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.cloudModel-Tuple{Int64}","page":"API","title":"BLR.cloudModel","text":"cloudModel(nClouds::Int64; μ::Float64=500., β::Float64=1.0, F::Float64=0.5, rₛ::Float64=1.0, θₒ::Float64=π/2, γ::Float64=1.0, ξ::Float64=1.0, i::Float64=0.0, I::Union{Function,Float64}=IsotropicIntensity, v::Union{Function,Float64}=vCircularCloud, rng::AbstractRNG=Random.GLOBAL_RNG, kwargs...)\n\nUses the model constructor to create a cloud model of the BLR similar to Pancoast+ 2011 and 2014.\n\nParameters\n\nnClouds::Int64: Number of clouds\nμ::Float64=500.: Mean radius of model (in terms of r_s)\nβ::Float64=1.0: Shape parameter for radial distribution\nF::Float64=0.5: Minimum fraction of maximum radius where clouds can be placed\nrₛ::Float64=1.0: Scale radius (in terms of r_s)\nθₒ::Float64=π/2: Maximum opening angle of cloud distribution (rad)\nγ::Float64=1.0: Disk concentration parameter\nξ::Float64=1.0: Fraction of clouds in back side that have not been moved to the front (when ξ = 1.0 clouds equally distributed front - back and when ξ = 0.0 all clouds are on the front side) \ni::Float64=0.0: Inclination angle of system (rad)\nI::Union{Function,Float64}=IsotropicIntensity: Intensity function\nv::Union{Function,Float64}=vCircularCloud: Velocity function\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\nkwargs...: Extra keyword arguments for I and v functions (see examples)\n\nReturns\n\nmodel object\n\nNote\n\nSimilar to other cloudModel method but here random values are generated for ϕ₀, rot, and θₒ ,i,rot,θ,θₒ,ξ, rₛ=rₛ,μ=μ,β=β,F=F,I=I,v=v,rng=rng;kwargs...) while keeping i constant for the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.cloudModel-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64}","page":"API","title":"BLR.cloudModel","text":"cloudModel(ϕ₀::Vector{Float64}, i::Vector{Float64}, rot::Vector{Float64}, θₒ::Vector{Float64}, θₒSystem::Float64, ξ::Float64; rₛ::Float64=1.0, μ::Float64=500., β::Float64=1.0, F::Float64=0.5, I::Union{Function,Float64}=IsotropicIntensity, v::Union{Function,Float64}=vCircularCloud, kwargs...)\n\nUses the model constructor to create a cloud model of the BLR similar to Pancoast+ 2011 and 2014.\n\nParameters\n\nϕ₀::Vector{Float64}: Initial azimuthal angle of cloud (rad) \ni::Vector{Float64}: Inclination angle (rad) \nrot::Vector{Float64}: Random rotation of cloud about z axis (rad) \nθₒ::Vector{Float64}: Opening angle of cloud (rad) \nθₒSystem::Float64: Maximum opening angle of the system (rad) \nξ::Float64: Fraction of clouds in back side that have not been moved to the front (when ξ = 1.0 clouds equally distributed front - back and when ξ = 0.0 all clouds are on the front side) \n\nOptional Parameters\n\nrₛ::Float64=1.0: Scale radius (in terms of r_s)\nμ::Float64=500.: Mean radius of model (in terms of r_s)\nβ::Float64=1.0: Shape parameter for radial distribution\nF::Float64=0.5: Beginning radius in units of μ where clouds can be placed. \nI::Union{Function,Float64}=IsotropicIntensity: Intensity function\nv::Union{Function,Float64}=vCircularCloud: Velocity function\nkwargs...: Extra keyword arguments for I and v functions (see examples)\n\nReturns\n\nmodel object\n\nNote\n\nSimilar to other cloudModel method but here you must explicitly pass ϕ₀, i, rot, and θₒ.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getFlattenedCameraIndices-Tuple{BLR.model}","page":"API","title":"BLR.getFlattenedCameraIndices","text":"getFlattenedCameraIndices(m::model) -> Vector{Int}\n\nGet flattened camera indices corresponding to rings in model.\n\nArguments\n\nm::model: Model object to extract camera indices from\n\nReturns\n\ncamStartInds::Vector{Int}: Vector of camera starting indices with length equal to m.subModelStartInds\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getProfile-Tuple{BLR.model, Union{Function, String, Symbol}}","page":"API","title":"BLR.getProfile","text":"getProfile(m::model, name::Union{String,Symbol,Function}; \n           bins::Union{Int,Vector{Float64}}=100, \n           dx::Union{Array{Float64,},Nothing}=nothing, kwargs...)\n\nReturn a profile for the model based on the specified name.\n\nArguments\n\nm: Model object to get the profile from\nname: Name of the profile to get. Options include:\n:line: Returns the line profile (integrated intensity as function of velocity)\n:delay: Returns the delay profile (mean delays weighted by intensity/responsivity vs. velocity)\n:r: Returns the mean radius (weighted by intensity) as function of velocity \n:ϕ: Returns the mean azimuthal angle (weighted by intensity) as function of velocity\n:phase: Returns the phase profile (integrated phase as function of velocity)\nRequires U [Mλ], V [Mλ], PA [rad], and BLRAng [rad] as keyword arguments\nFunction: Returns the intensity weighted mean of this function vs. velocity\nbins: Number of bins or bin edges for binning\nIf Int: Number of bins with edges equally spaced between min/max velocity\nIf Vector{Float64}: Specific bin edges, with number of bins = length(bins)-1\nLeft edge inclusive, right edge exclusive (except last bin which is inclusive)\ndx: Integration element for each ring (defaults to ΔA in each ring struct if nothing)\nAdditional kwargs passed to binModel include:\noverflow=true: Include overflow bins\ncentered=true: Center bins around 0.0\nminX, maxX: Set min/max bin boundaries\n\nReturns\n\nprofile: A profile object containing bin edges, bin centers, and binned sums. Assign to a model object using setProfile! to store the profile in the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getRingFromFlattenedInd-Tuple{BLR.model, Int64}","page":"API","title":"BLR.getRingFromFlattenedInd","text":"getRingFromFlattenedInd(m::model, flattenedInd::Int) -> Tuple{Int, Int}\n\nRetrieve the model ring index and subindex (if applicable) from flattened array index.\n\nArguments\n\nm::model: Model object with rings \nflattenedInd::Int: The index in the flattened array we need to work back from\n\nReturns\n\nrow::Int: The ring index in model.rings that the flattened index corresponds to\ncolumn::Int: The subindex that matches the flattened index passed to this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getVariable-Tuple{BLR.model, Function}","page":"API","title":"BLR.getVariable","text":"getVariable(m::model, variable::Function; flatten=false) -> Array{Float64}\n\nRetrieve model variable when specified as a Function. See main docstring for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getVariable-Tuple{BLR.model, String}","page":"API","title":"BLR.getVariable","text":"getVariable(m::model, variable::Union{String,Symbol,Function}; flatten=false)\n\nRetrieve elements from model object and stack them into matrices for easy manipulation.\n\nArguments\n\nm::model: Model object to extract variables from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nflatten::Bool=false: If true, flatten the result to a vector\n\nReturns\n\nArray{Float64,}: Matrix or vector of extracted variable from model.rings, created by stacking the output variable for each ring\nFor example, if variable given is :I, result will have shape (length(r), length(ϕ)) as at each r and ϕ there is a value of I\nIf flatten=true, result will be a flattened vector\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getVariable-Tuple{BLR.model, Symbol}","page":"API","title":"BLR.getVariable","text":"getVariable(m::model, variable::Symbol; flatten=false) -> Array{Float64}\n\nRetrieve model variable when specified as a Symbol. See main docstring for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.get_r3D-Tuple{Any, Any, Any}","page":"API","title":"BLR.get_r3D","text":"get_r3D(i::Float64, rot::Float64, θₒ::Float64) -> Matrix{Float64}\n\nCalculate rotation matrix to transform from initial XY plane coordinates to 3D space.\n\nParameters\n\ni::Float64: Inclination angle of ring (rad)\nrot::Float64: Rotation of ring plane about z axis (rad)\nθₒ::Float64: Opening angle of point (rad)\n\nReturns\n\nmatrix::Matrix{Float64}: 3×3 rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getΨ-Tuple{BLR.model, Array{Float64}, Array{Float64}}","page":"API","title":"BLR.getΨ","text":"getΨ(m::model,vEdges::Array{Float64},tEdges::Array{Float64})\n\nCalculate the 2D transfer function Ψ for a model m over specified velocity and time bins, whose edges are given by vEdges and tEdges.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getΨ-Tuple{BLR.model, Int64, Int64}","page":"API","title":"BLR.getΨ","text":"getΨ(m::model,vBins::Int64,tBins::Int64)\n\nCalculate the 2D transfer function Ψ for a model m over specified number of velocity bins vBins and time bins tBins. The velocity and time edges are automatically calculated based on the minimum and maximum values for velocity and delays in the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.getΨt","page":"API","title":"BLR.getΨt","text":"getΨt(m::model,tBins::Int64,maxT::Float64=Inf,overflow::Bool=false)\n\nCalculate the 1D transfer function Ψ(t) for a model m over specified number of time bins tBins. The maxT parameter specifies the maximum time delay to consider, and overflow determines whether to include contributions from delays outside the specified edges in the edge bins.\n\n\n\n\n\n","category":"function"},{"location":"api/#BLR.getΨt-2","page":"API","title":"BLR.getΨt","text":"getΨt(m::model,tEdges::Array{Float64},overflow::Bool=false;)\n\nCalculate the 1D transfer function Ψ(t) for a model m over specified time edges tEdges. The overflow parameter determines whether to include contributions from delays outside the specified edges in the edge bins.\n\n\n\n\n\n","category":"function"},{"location":"api/#BLR.image!-Tuple","page":"API","title":"BLR.image!","text":"BLR.image(m::model, variable::Union{String,Symbol,Function}, kwargs...)\n\nGenerate an image of the model where the color of each point is determined by the variable provided.\n\nArguments\n\nm::model: Model object to extract variable from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\n\nKeywords\n\nAdditional keyword arguments are passed to Plots.plot\n\nReturns\n\np::Plots.plot: Plot object representing the generated image\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.image!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"API","title":"BLR.image!","text":"BLR.image(m::model, variable::Union{String,Symbol,Function}, kwargs...)\n\nGenerate an image of the model where the color of each point is determined by the variable provided.\n\nArguments\n\nm::model: Model object to extract variable from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\n\nKeywords\n\nAdditional keyword arguments are passed to Plots.plot\n\nReturns\n\np::Plots.plot: Plot object representing the generated image\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.image-Tuple","page":"API","title":"BLR.image","text":"BLR.image(m::model, variable::Union{String,Symbol,Function}, kwargs...)\n\nGenerate an image of the model where the color of each point is determined by the variable provided.\n\nArguments\n\nm::model: Model object to extract variable from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\n\nKeywords\n\nAdditional keyword arguments are passed to Plots.plot\n\nReturns\n\np::Plots.plot: Plot object representing the generated image\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.phase-Tuple{BLR.model}","page":"API","title":"BLR.phase","text":"phase(m::model; U, V, PA, BLRAng, returnAvg=false, offAxisInds=nothing, kwargs...)\n\nCalculate differential phase for a model ring.\n\nDescription\n\nComputes the differential phase signal that would be measured by an interferometer  for specified baselines, model orientation, and BLR angular size.\n\nArguments\n\nm::model: Model object to calculate phase for\nU::Vector{Float64}: U component of complex visibility in [Mλ]\nV::Vector{Float64}: V component of complex visibility in [Mλ]\nPA::Float64: On-sky position angle of the model in radians\nBLRAng::Float64: Characteristic size of the BLR model in radians (conversion from r_s to radians)\nreturnAvg::Bool=false: If true, returns the average phase across all baselines\noffAxisInds::Union{Nothing,Vector{Int}}=nothing: If provided, only calculates phase for baselines at specified indices\n\nReturns\n\nIf returnAvg=true: Tuple{Vector{Float64},Vector{Float64},Vector{Float64}} containing:\nBin edges for velocity\nBin centers for velocity\nAverage differential phase (in radians)\nIf returnAvg=false: Vector{Tuple{Vector{Float64},Vector{Float64},Vector{Float64}}} containing:\nFor each baseline, a tuple of bin edges, bin centers, and differential phase\n\nThe differential phase is calculated by integrating the phase over the model at each velocity bin, weighted by the intensity and area of each ring element.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.photograph","page":"API","title":"BLR.photograph","text":"photograph(r::Float64, ϕ₀::Float64, i::Float64, rot::Float64, θₒ::Float64, reflect::Bool=false)\n\nCalculate the image coordinates from system coordinates r, ϕ + inclination angle i.\n\nArguments\n\nr::Float64: radius from central mass (in terms of rₛ)\nϕ₀::Float64: unrotated azimuthal angle in ring plane (rad)\ni::Float64: inclination angle of ring plane (rad)\nrot::Float64: rotation of system plane about z axis (rad)\nθₒ::Float64: ring opening angle\nreflect::Bool=false: whether the point is reflected across the midplane of the disk\n\nReturns\n\nα::Float64: image x coordinate (in terms of rₛ)\nβ::Float64: image y coordinate (in terms of rₛ)\n\nNote\n\nThis function is coordinate photography only. To visualize models, see Image.`\n\n\n\n\n\n","category":"function"},{"location":"api/#BLR.plot3d!-Tuple","page":"API","title":"BLR.plot3d!","text":"plot3d(m::model, [variable], [annotatedCamera], [kwargs...])\n\nGenerate a 3D plot of the model geometry, optionally colored by a variable.\n\nParameters\n\nm::model: Model object to plot\nvariable::Union{String,Symbol,Function}=nothing: Variable to color the points by\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g., :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nIf not provided, defaults to nothing (no coloring)\nannotatedCamera::Bool=true: Whether to annotate the camera position and orientation in the plot\nkwargs...: Additional keyword arguments passed to Plots.plot\n\nReturns\n\np::Plots.plot: 3D plot of the model geometry, optionally colored by the variable provided\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.plot3d!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"API","title":"BLR.plot3d!","text":"plot3d(m::model, [variable], [annotatedCamera], [kwargs...])\n\nGenerate a 3D plot of the model geometry, optionally colored by a variable.\n\nParameters\n\nm::model: Model object to plot\nvariable::Union{String,Symbol,Function}=nothing: Variable to color the points by\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g., :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nIf not provided, defaults to nothing (no coloring)\nannotatedCamera::Bool=true: Whether to annotate the camera position and orientation in the plot\nkwargs...: Additional keyword arguments passed to Plots.plot\n\nReturns\n\np::Plots.plot: 3D plot of the model geometry, optionally colored by the variable provided\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.plot3d-Tuple","page":"API","title":"BLR.plot3d","text":"plot3d(m::model, [variable], [annotatedCamera], [kwargs...])\n\nGenerate a 3D plot of the model geometry, optionally colored by a variable.\n\nParameters\n\nm::model: Model object to plot\nvariable::Union{String,Symbol,Function}=nothing: Variable to color the points by\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g., :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nIf not provided, defaults to nothing (no coloring)\nannotatedCamera::Bool=true: Whether to annotate the camera position and orientation in the plot\nkwargs...: Additional keyword arguments passed to Plots.plot\n\nReturns\n\np::Plots.plot: 3D plot of the model geometry, optionally colored by the variable provided\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.profile!-Tuple","page":"API","title":"BLR.profile!","text":"profile(m::model, [variable], [kwargs...])\n\nPlot all profiles set in the model, normalized to the maximum value of each profile.\n\nArguments\n\nmodel: A model object containing profile data.\nvariable: Optional. A symbol or string (or list of symbols/strings) specifying which profile to plot. If not provided, all profiles set in model will be plotted.\nkwargs...: Additional keyword arguments passed to Plots.plot\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.profile!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"API","title":"BLR.profile!","text":"profile(m::model, [variable], [kwargs...])\n\nPlot all profiles set in the model, normalized to the maximum value of each profile.\n\nArguments\n\nmodel: A model object containing profile data.\nvariable: Optional. A symbol or string (or list of symbols/strings) specifying which profile to plot. If not provided, all profiles set in model will be plotted.\nkwargs...: Additional keyword arguments passed to Plots.plot\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.raytrace!-Tuple{BLR.model}","page":"API","title":"BLR.raytrace!","text":"raytrace!(m::model; IRatios::Union{Float64,Array{Float64,}}=1.0, τCutOff::Float64=1.0, raytraceFreeClouds::Bool=false)\n\nPerform raytracing for a model, combining overlapping components along line of sight.\n\nThis function should be called after combining all relevant models (i.e. mCombined = m1 + m2 + m3...). It performs raytracing in discrete steps (no absorption, only adding intensity in chunks along  the line of sight until maximum optical depth τ is reached) and generates a new model object  with extraneous points removed. Note that this function will mutate the input model objects.\n\nArguments\n\nm::model: Model to raytrace\nIRatios::Union{Float64,Array{Float64,}}=1.0: Intensity ratios for each submodel\nIf Float64, applies to all submodels equally\nIf array, applies to each submodel individually (must match number of submodels)\nUsed when combining models with different intensity functions if they aren't properly normalized\nτCutOff::Float64=1.0: Maximum optical depth to raytrace to (stops when τ > τCutOff)\nraytraceFreeClouds::Bool=false: Whether to raytrace free clouds (cloud-cloud raytracing)\nIf false, clouds are only raytraced if they overlap with a continuous model\nIf true, clouds will be checked for overlap with other clouds and raytraced accordingly\n\nReturns\n\nm::model: Model with raytraced points\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.raytrace-NTuple{5, Float64}","page":"API","title":"BLR.raytrace","text":"raytrace(α::Float64, β::Float64, i::Float64, rot::Float64, θₒPoint::Float64)\n\nCalculate where ray traced back from camera coordinates α and β intersects the system (assumes circular geometry).\n\nArguments\n\nα::Float64: image x coordinate (in terms of rₛ)\nβ::Float64: image y coordinate (in terms of rₛ)\ni::Float64: inclination angle of system (rad)\nrot::Float64: how the point was rotated about z axis (rad)\nθₒPoint::Float64: opening angle of current point\n\nReturns\n\nr::Float64: distance from central mass (in terms of rₛ)\nϕ::Float64: azimuthal angle of system ring plane at intersection\nϕ₀::Float64: original azimuthal angle in ring plane (no rotation)\n\nNote\n\nThis function is coordinate raytracing only. To raytrace models and combine intensities, see raytrace!. \n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.raytrace-Tuple{Float64, Float64, Float64, Float64, Float64, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Vector{Float64}}","page":"API","title":"BLR.raytrace","text":"raytrace(α::Float64, β::Float64, i::Float64, rot::Float64, θₒPoint::Float64, r3D::Matrix{Float64}, xyz::Vector{Float64}, matBuff::Matrix{Float64}, colBuff::Vector{Float64})\n\nPerformant version of raytrace function – calculate where ray traced back from camera coordinates α, β intersects the system (assumes circular geometry).\n\nArguments\n\nα::Float64: image x coordinate (in terms of rₛ)\nβ::Float64: image y coordinate (in terms of rₛ)\ni::Float64: inclination angle of system (rad)\nrot::Float64: rotation of current point about z axis (rad)\nθₒPoint::Float64: opening angle of current point\nr3D::Matrix{Float64}: matrix that rotates system plane into XY plane\nxyz::Vector{Float64}: preallocated xyz vector (but not precalculated)\nmatBuff::Matrix{Float64}: preallocated buffer matrix for storing result of 3x3 matrix multiplication\ncolBuff::Vector{Float64}: preallocated buffer vector for storing final matrix multiplication result\n\nReturns\n\nr::Float64: distance from central mass (in terms of rₛ)\nϕ::Float64: azimuthal angle of system ring plane at intersection\nϕ₀::Float64: original azimuthal angle in ring plane\n\nNote\n\nThis function is coordinate raytracing only. To raytrace models and combine intensities, see raytrace!. \n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.reflect!-Tuple{Any, Any}","page":"API","title":"BLR.reflect!","text":"reflect!(xyzSys::Vector{Float64}, i::Float64) -> Vector{Float64}\n\nReflect coordinates in 3D space across the ring plane.\n\nParameters\n\nxyzSys::Vector{Float64}: [x;y;z] coordinates in 3D space\ni::Float64}: Inclination angle of ring plane (rad)\n\nReturns\n\nxyzSys::Vector{Float64}: [x';y';z'] coordinates in 3D space after reflection\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.removeDiskObscuredClouds!","page":"API","title":"BLR.removeDiskObscuredClouds!","text":"removeDiskObscuredClouds!(m::model, rotate3D::Function=rotate3D)\n\nRemove clouds that are obscured by the disk.\n\nPerforms simple raytracing for an optically thick obscuring disk. The function modifies the input model by removing cloud points that are obscured by the disk. Note that this is a mutating operation and the input model will be modified in place.\n\nArguments\n\nm::model: Model to remove disk obscured clouds. Should be a combined model consisting  of a disk component and a cloud component.\nrotate3D::Function=rotate3D: Function to rotate coordinates in 3D space\n\nReturns\n\nm::model: Model with disk obscured clouds removed\n\nSee also\n\nzeroDiskObscuredClouds!: Function to zero out disk obscured clouds instead of removing them\n\n\n\n\n\n","category":"function"},{"location":"api/#BLR.removeNaN!-Tuple{BLR.model}","page":"API","title":"BLR.removeNaN!","text":"removeNaN!(m::model) -> model\n\nRemove points with I = NaN from model.\n\nParameters\n\nm::model: Model to remove points from\n\nReturns\n\nm::model: Model with NaN points removed\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.reset!-Tuple{BLR.model}","page":"API","title":"BLR.reset!","text":"reset!(m::model; profiles=true, img=false)\n\nErase existing profiles/imgs.\n\nParameters\n\nm::model: Model object to reset\nprofiles::Bool=true: If true, reset profiles\nimg::Bool=false: If true, reset raytracing boolean (does not change existing model but allows model to be raytraced again after combining other new models)\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.response-Tuple{Float64}","page":"API","title":"BLR.response","text":"response(r::Float64; ηₒ::Float64=0.5, η₁::Float64=0.5, αRM::Float64=0.0, rNorm::Float64=1.0, _...)\n\nCalculate response function for use in reverberation mapping calculations.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.rotate3D","page":"API","title":"BLR.rotate3D","text":"rotate3D(r::Float64, ϕ₀::Float64, i::Float64, rot::Float64, θₒ::Float64, reflect::Bool=false) -> Tuple{Float64, Float64, Float64}\n\nTransform from ring coordinates to 3D coordinates where camera is at +x.\n\nParameters\n\nr::Float64: Radius from central mass (in terms of rₛ)\nϕ₀::Float64: Starting azimuthal angle in ring plane (rad)\ni::Float64: Inclination angle of ring plane (rad)\nrot::Float64: Rotation of system plane about z axis (rad)\nθₒ::Float64: Opening angle of point (rad)\nreflect::Bool=false: Whether to reflect across the ring plane\n\nReturns\n\nTuple{Float64, Float64, Float64}: (x, y, z) coordinates in 3D space\n\n\n\n\n\n","category":"function"},{"location":"api/#BLR.setProfile!-Tuple{BLR.model, profile}","page":"API","title":"BLR.setProfile!","text":"setProfile!(m::model, p::profile; overwrite::Bool=false)\n\nSet a profile in the model's profiles dictionary. If the profile already exists and overwrite is false, a warning is issued.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.t-Tuple{BLR.ring}","page":"API","title":"BLR.t","text":"tDisk(ring::ring; kwargs...)\n\nCalculate time delays for a point in a disk as t = eta r left(1 + cos(phi) sin(i)right).\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.vCirc","page":"API","title":"BLR.vCirc","text":"vCirc(r::Float64, rₛ::Float64=1.0)\n\nCalculate circular velocity at radius r from central mass, with Schwarzschild radius rₛ.\n\nDefaults to rₛ=1.0 for unitless calculations.\n\n\n\n\n\n","category":"function"},{"location":"api/#BLR.vCircularCloud-Tuple{}","page":"API","title":"BLR.vCircularCloud","text":"vCircularCloud(;r::Float64, ϕ₀::Float64, i::Float64, rot::Float64, θₒ::Float64, rₛ::Float64=1.0, reflect::Bool=false, _...)\n\nCalculate line of sight velocity for cloud in 3D space.\n\nArguments\n\nr::Float64: radius from central mass (in terms of rₛ)\nϕ₀::Float64: starting azimuthal angle in ring plane (rad)\ni::Float64: inclination angle of ring plane (rad)\nrot::Float64: rotation of system plane about z axis (rad)\nθₒ::Float64: opening angle of point\nrₛ::Float64=1.0: Schwarzschild radius (optional, to convert to physical units)\nreflect::Bool=false: whether the point is reflected across the midplane of the disk\n_...: extra kwargs, ignored\n\nReturns\n\nLine of sight velocity (Float64)\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.vCircularDisk-Tuple{}","page":"API","title":"BLR.vCircularDisk","text":"vCircularDisk(;r::Union{Float64,Vector{Float64}}, i::Float64, ϕ::Union{Vector{Float64},Float64}, θₒ::Union{Vector{Float64},Float64}, rₛ=1.0, _...)\n\nCalculate line of sight velocity for circular orbit at radius r from central mass and inclined at angle i (rad) over grid of azimuthal angles ϕ (rad).\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.vCircularRadialDisk-Tuple{}","page":"API","title":"BLR.vCircularRadialDisk","text":"vCircularRadialDisk(;r::Union{Float64,Vector{Float64}}, i::Float64, ϕ::Union{Vector{Float64},Float64}, vᵣFrac::Union{Vector{Float64},Float64}=0.0, inflow::Union{Vector{Bool},Bool}=true, rₛ=1.0, _...)\n\nCalculate line of sight velocity for circular orbit at radius r from central mass and inclined at angle i (rad) over grid of azimuthal angles ϕ (rad) with radial inflow/outflow.\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.vCloudTurbulentEllipticalFlow-Tuple{}","page":"API","title":"BLR.vCloudTurbulentEllipticalFlow","text":"vCloudTurbulentEllipticalFlow(;σρᵣ::Float64, σρc::Float64, σΘᵣ::Float64, σΘc::Float64, θₑ::Float64, fEllipse::Float64, fFlow::Float64, σₜ::Float64, r::Float64, i::Float64, rot::Float64, θₒ::Float64, rₛ::Float64=1.0, ϕ₀::Float64=0.0, reflect::Bool=false, rng::AbstractRNG=Random.GLOBAL_RNG, _...)\n\nCalculate line of sight velocity for cloud in 3D space with potential for elliptical orbital velocities, in/outflow, and turbulence as in Pancoast+14.\n\nArguments\n\nσρᵣ::Float64: Radial standard deviation around radial orbits\nσρc::Float64: Radial standard deviation around circular orbits\nσΘᵣ::Float64: Angular standard deviation around radial orbits\nσΘc::Float64: Angular standard deviation around circular orbits\nθₑ::Float64: Angle in vϕ-vr plane\nfEllipse::Float64: Fraction of elliptical orbits\nfFlow::Float64: If < 0.5, inflow, otherwise, outflow\nσₜ::Float64: Standard deviation of turbulent velocity \nr::Float64: Radius from central mass (in terms of rₛ)\ni::Float64: Inclination angle of ring plane (rad)\nrot::Float64: Rotation of system plane about z axis (rad)\nθₒ::Float64: Opening angle of point\nrₛ::Float64=1.0: Schwarzschild radius (optional, to convert to physical units)\nϕ₀::Float64=0.0: Starting azimuthal angle in ring plane (rad)\nreflect::Bool=false: Whether the point is reflected across the midplane of the disk\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\n_...: Extra kwargs, ignored\n\nReturns\n\nLine of sight velocity (Float64)\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.zeroDiskObscuredClouds!-Tuple{BLR.model}","page":"API","title":"BLR.zeroDiskObscuredClouds!","text":"zeroDiskObscuredClouds!(m::model; diskCloudIntensityRatio::Float64=1.0, rotate3D::Function=rotate3D)\n\nZero out the intensities of clouds that are obscured by the disk.\n\nPerforms simple raytracing for an optically thick obscuring disk. The function modifies the input model by setting the intensity of obscured cloud points to zero and adjusting the disk intensity according to the specified ratio.\n\nArguments\n\nm::model: Model to zero out disk obscured clouds. Should be a combined model consisting of a disk component and a cloud component. \ndiskCloudIntensityRatio::Float64=1.0: Ratio of disk to cloud intensity, used to scale  the disk intensities after zeroing out clouds\nrotate3D::Function=rotate3D: Function to rotate coordinates in 3D space\n\nReturns\n\nm::model: Model with disk obscured clouds zeroed out\n\nSee also\n\nremoveDiskObscuredClouds!: Function to remove disk obscured clouds instead of zeroing them out\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.camera","page":"API","title":"BLR.camera","text":"camera\n\nCamera coordinates struct.\n\nFields\n\nα::Union{Vector{Float64}, Matrix{Float64}}: x values in the camera plane\nβ::Union{Vector{Float64}, Matrix{Float64}}: y values in the camera plane\nraytraced::Bool: whether the camera has been used to raytrace the model\n\n\n\n\n\n","category":"type"},{"location":"api/#BLR.model","page":"API","title":"BLR.model","text":"model\n\nA mutable structure to hold many rings and their parameters that model the BLR.\n\nFields\n\nrings::Vector{ring}: List of ring objects, see ring struct\nprofiles::Union{Nothing,Dict{Symbol,profile}}: Dictionary of profiles (see profile struct) with keys as symbols; optional, usually initialized to empty dictionary and filled in with setProfile!\ncamera::Union{Nothing,camera}: Camera coordinates (α,β) corresponding to each ring used to generate images and in raytracing, see camera struct\nsubModelStartInds::Vector{Int}: Indices of start of each submodel in list of rings; used to separate out submodels for raytracing or for the recovery of individual models after being combined\n\nConstructors\n\nmodel(rings::Vector{ring}, profiles::Union{Nothing,Dict{Symbol,profile}}, camera::Union{Nothing,camera}, subModelStartInds::Vector{Int}) \n\nthe most flexible constructor, takes in user supplied vector of ring objects, optional dictionary of profiles, optional camera coordinates, and vector of indices for submodels\n\nmodel(rings::Vector{ring{Vector{Float64},Float64}})\n\ncloud model constructor, takes in a vector of ring objects that are each points in space and returns a model object with camera coordinates calculated from the physical parameters of each ring\n\nmodel(rMin::Float64, rMax::Float64, i::Float64, nr::Int, nϕ::Int, I::Function, v::Function, scale::Symbol; kwargs...)\n\ndisk-wind model constructor, takes in minimum and maximum radius, inclination angle, number of radial and azimuthal bins, intensity and velocity functions, and scale for radial binning; returns a model object with rings generated from these parameters\n\nmodel(r̄::Float64, rFac::Float64, Sα::Float64, i::Float64, nr::Int, nϕ::Int, scale::Symbol; kwargs...)\n\ndisk-wind model constructor, takes in average radius, radius scaling factor, power law for source function, inclination angle, number of radial and azimuthal bins, and scale for radial binning; returns a model object with rings generated from these parameters\n\n\n\n\n\n","category":"type"},{"location":"api/#BLR.profile","page":"API","title":"BLR.profile","text":"profile\n\nA struct to hold binned data, usually bound to model struct with profiles.jl#setProfile!.\n\nFields\n\nname::Symbol: Name of profile\nbinCenters::Vector{Float64}: Bin centers \nbinEdges::Vector{Float64}: Bin edges\nbinSums::Vector{Float64}: Sum of values in each bin (crude integral over bin)\n\n\n\n\n\n","category":"type"},{"location":"api/#BLR.profile-Tuple","page":"API","title":"BLR.profile","text":"profile(m::model, [variable], [kwargs...])\n\nPlot all profiles set in the model, normalized to the maximum value of each profile.\n\nArguments\n\nmodel: A model object containing profile data.\nvariable: Optional. A symbol or string (or list of symbols/strings) specifying which profile to plot. If not provided, all profiles set in model will be plotted.\nkwargs...: Additional keyword arguments passed to Plots.plot\n\n\n\n\n\n","category":"method"},{"location":"api/#BLR.ring","page":"API","title":"BLR.ring","text":"ring{V,F} <: AbstractRing{V,F}\n\nA mutable structure to hold parameters of each model ring, where the \"ring\" is a circle in the camera plane observing the BLR.\n\nFields\n\nr: Distance from central mass (in terms of r_s)\nUnion{Vector{Float64}, Float64, Function}\nCan be a single value for constant radius, or vector corresponding to azimuthal angles\nCan be a function returning Vector{Float64} or Float64\ni: Inclination angle in radians\nUnion{Vector{Float64}, Float64}\nMust be between 0 and pi2, with 0 being face-on and pi2 being edge-on\nrot: Rotation of system plane about z-axis in radians\nUnion{Vector{Float64}, Float64}\nθₒ: Opening angle of ring in radians\nUnion{Vector{Float64}, Float64}\nShould be between 0 and pi2\nv: Line of sight velocity\nUnion{Vector{Float64}, Float64, Function}\nCan be a function that calculates velocity from other parameters\nI: Intensity\nUnion{Vector{Float64}, Float64, Matrix{Float64}, Function}\nCan be a function that calculates intensity from other parameters\nϕ: Azimuthal angle in radians\nUnion{Vector{Float64}, Float64}\nϕ₀: Initial azimuthal angle before rotation in radians\nUnion{Vector{Float64}, Float64}\nDefaults to 0.0 if not provided or if rot is 0.0\nΔA: Projected area of each ring element in image\nUnion{Vector{Float64}, Float64}\nUsed in calculating profiles\nreflect: Whether cloud is reflected across disk mid-plane\nUnion{Bool, Array{Bool,}}\nτ: Optical depth\nUnion{Vector{Float64}, Float64, Function}\nη: Response parameter for reverberation\nUnion{Vector{Float64}, Float64, Function}\nΔr: Distance between camera pixels in r\nFloat64\nΔϕ: Distance between camera pixels in ϕ\nFloat64\nscale: Encoding for camera ring scaling\nUnion{Nothing, Symbol}\n:log or :linear scale\n\nConstructor\n\nring(; r, i, v, I, ϕ, rot=0.0, θₒ=0.0, ϕ₀=0.0, ΔA=1.0, reflect=false, τ=0.0, η=1.0, Δr=1.0, Δϕ=1.0, scale=nothing, kwargs...)\n\nRequired parameters:\n\nr, i, v, I, ϕ\n\nOptional parameters with defaults:\n\nrot=0.0, θₒ=0.0, ϕ₀=0.0, ΔA=1.0, reflect=false, τ=0.0, η=1.0, Δr=1.0, Δϕ=1.0, scale=nothing\n\nAdditional keyword arguments are passed to the r, v, I, and τ functions if they are provided as functions.\n\n\n\n\n\n","category":"type"},{"location":"usage_examples/#Usage-and-Examples","page":"Usage and Examples","title":"Usage and Examples","text":"","category":"section"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"lorem ipsum dolor...","category":"page"},{"location":"installation/#Installation-guide","page":"Installation","title":"Installation guide","text":"","category":"section"},{"location":"installation/#Julia","page":"Installation","title":"Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Make sure you have a working version of Julia accessible on your system. \nAdd the package from the package manager \nUse the package either with import BLR or using BLR in Julia.","category":"page"},{"location":"installation/#Python","page":"Installation","title":"Python","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"lorem\nipsum\ndolor","category":"page"},{"location":"#BLR.jl","page":"Home","title":"BLR.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"***A fast and flexible toolkit for modeling the broad-line region (BLR) in Julia***","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Define a cloud model with syntax like: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"mClouds = BLR.cloudModel(100_000,μ=500.,β=1.,F=0.5,θₒ=30/180*π,γ=1.,ξ=1.,i=0.,I=BLR.IsotropicIntensity,v=BLR.vCircularCloud,rescale=1e-5,τ=0.0)","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find this code useful in your work, please cite it as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"lorem ipsum","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you would like to contribute to the package, please open a pull request on the GitHub. For bug reports and feature requests, please open an issue on the GitHub. ","category":"page"}]
}
