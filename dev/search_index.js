var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Reference for BroadLineRegions.jl's public interface. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"note: Note\nNo methods are exported by default into the global namespace to prevent overlap with other modules, and you must prepend the module name to all methods to access them. BroadLineRegions.jl exports itself as both BroadLineRegions and BLR, so both of these prefixes are equivalent, i.e. BroadLineRegions.model == BLR.model. If prepending this to function calls annoys you you can always manually import whatever you desire into the global space with syntax like: using BLR: DiskWindModel, cloudModel","category":"page"},{"location":"api/#Full-documentation","page":"API","title":"Full documentation","text":"","category":"section"},{"location":"api/#BroadLineRegions.DiskWindModel-NTuple{4, Float64}","page":"API","title":"BroadLineRegions.DiskWindModel","text":"DiskWindModel(r̄::Float64, rFac::Float64, α::Float64, i::Float64; rot::Float64=0.0, \n        nr::Int=128, nϕ::Int=256, scale::Symbol=:log, kwargs...)\n\nUses the model constructor to create a DiskWind model of the BLR as detailed in Long+2023 and Long+2025.\n\nParameters\n\nr̄::Float64: Mean radius of model (in terms of r_s)\nrFac::Float64: Radius factor\nα::Float64: Power-law source function scaling\ni::Float64: Inclination angle in radians\nrot::Float64=0.0: Rotation of system plane about z-axis in radians\nnr::Int=128: Number of radial bins\nnϕ::Int=256: Number of azimuthal bins\nscale::Symbol=:log: Radial binning scale (:log or :linear)\nkwargs...: Extra keyword arguments for model constructor (see examples)\n\nReturns\n\nmodel object\n\nNote\n\nSimilar to another DiskWind model constructor but here we pass r̄, rFac, and α.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.DiskWindModel-Tuple{Float64, Float64, Float64}","page":"API","title":"BroadLineRegions.DiskWindModel","text":"DiskWindModel(rMin::Float64, rMax::Float64, i::Float64; nr::Int=128, nϕ::Int=256, \n        I::Function=DiskWindIntensity, v::Function=vCircularDisk, scale::Symbol=:log, kwargs...)\n\nUses the model constructor to create a DiskWind model of the BLR as detailed in Long+2023 and Long+2025.\n\nParameters\n\nrMin::Float64: Minimum radius of model (in terms of r_s)\nrMax::Float64: Maximum radius of model (in terms of r_s)\ni::Float64: Inclination angle in radians (all rings have the same inclination)\nnr::Int=128: Number of radial bins\nnϕ::Int=256: Number of azimuthal bins\nI::Function=DiskWindIntensity: Intensity function\nv::Function=vCircularDisk: Velocity function\nscale::Symbol=:log: Radial binning scale (:log or :linear)\nkwargs...: Extra keyword arguments for I and v functions (see examples)\n\nReturns\n\nmodel object\n\nNote\n\nSimilar to other DiskWind model constructor but must explicitly pass rMin and rMax.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.cloudModel-Tuple{Int64}","page":"API","title":"BroadLineRegions.cloudModel","text":"cloudModel(nClouds::Int64; μ::Float64=500., β::Float64=1.0, F::Float64=0.5, rₛ::Float64=1.0, θₒ::Float64=π/2, γ::Float64=1.0, ξ::Float64=1.0, i::Float64=0.0, I::Union{Function,Float64}=IsotropicIntensity, v::Union{Function,Float64}=vCircularCloud, rng::AbstractRNG=Random.GLOBAL_RNG, kwargs...)\n\nUses the model constructor to create a cloud model of the BLR similar to Pancoast+ 2011 and 2014.\n\nParameters\n\nnClouds::Int64: Number of clouds\nμ::Float64=500.: Mean radius of model (in terms of r_s)\nβ::Float64=1.0: Shape parameter for radial distribution\nF::Float64=0.5: Minimum fraction of maximum radius where clouds can be placed\nrₛ::Float64=1.0: Scale radius (in terms of r_s)\nθₒ::Float64=π/2: Maximum opening angle of cloud distribution (rad)\nγ::Float64=1.0: Disk concentration parameter\nξ::Float64=1.0: Fraction of clouds in back side that have not been moved to the front (when ξ = 1.0 clouds equally distributed front - back and when ξ = 0.0 all clouds are on the front side) \ni::Float64=0.0: Inclination angle of system (rad)\nI::Union{Function,Float64}=IsotropicIntensity: Intensity function\nv::Union{Function,Float64}=vCircularCloud: Velocity function\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\nkwargs...: Extra keyword arguments for I and v functions (see examples)\n\nReturns\n\nmodel object\n\nNote\n\nSimilar to other cloudModel method but here random values are generated for ϕ₀, rot, and θₒ ,i,rot,θ,θₒ,ξ, rₛ=rₛ,μ=μ,β=β,F=F,I=I,v=v,rng=rng;kwargs...) while keeping i constant for the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.cloudModel-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64}","page":"API","title":"BroadLineRegions.cloudModel","text":"cloudModel(ϕ₀::Vector{Float64}, i::Vector{Float64}, rot::Vector{Float64}, θₒ::Vector{Float64}, \n        θₒSystem::Float64, ξ::Float64; rₛ::Float64=1.0, μ::Float64=500., β::Float64=1.0, F::Float64=0.5, \n        I::Union{Function,Float64}=IsotropicIntensity, v::Union{Function,Float64}=vCircularCloud, kwargs...)\n\nUses the model constructor to create a cloud model of the BLR similar to Pancoast+ 2011 and 2014.\n\nParameters\n\nϕ₀::Vector{Float64}: Initial azimuthal angle of cloud (rad) \ni::Vector{Float64}: Inclination angle (rad) \nrot::Vector{Float64}: Random rotation of cloud about z axis (rad) \nθₒ::Vector{Float64}: Opening angle of cloud (rad) \nθₒSystem::Float64: Maximum opening angle of the system (rad) \nξ::Float64: Fraction of clouds in back side that have not been moved to the front (when ξ = 1.0 clouds equally distributed front - back and when ξ = 0.0 all clouds are on the front side) \nrₛ::Float64=1.0: Scale radius (in terms of r_s)\nμ::Float64=500.: Mean radius of model (in terms of r_s)\nβ::Float64=1.0: Shape parameter for radial distribution\nF::Float64=0.5: Beginning radius in units of μ where clouds can be placed. \nI::Union{Function,Float64}=IsotropicIntensity: Intensity function\nv::Union{Function,Float64}=vCircularCloud: Velocity function\nkwargs...: Extra keyword arguments for I and v functions (see examples)\n\nReturns\n\nmodel object\n\nNote\n\nSimilar to other cloudModel method but here you must explicitly pass ϕ₀, i, rot, and θₒ.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.camera","page":"API","title":"BroadLineRegions.camera","text":"camera\n\nCamera coordinates struct.\n\nFields\n\nα::Union{Vector{Float64}, Matrix{Float64}}: x values in the camera plane\nβ::Union{Vector{Float64}, Matrix{Float64}}: y values in the camera plane\nraytraced::Bool: whether the camera has been used to raytrace the model\n\n\n\n\n\n","category":"type"},{"location":"api/#BroadLineRegions.model","page":"API","title":"BroadLineRegions.model","text":"model\n\nA mutable structure to hold many rings and their parameters that model the BLR.\n\nFields\n\nrings::Vector{ring}: List of ring objects, see ring struct\nprofiles::Union{Nothing,Dict{Symbol,profile}}: Dictionary of profiles (see profile struct) with keys as symbols; optional, usually initialized to empty dictionary and filled in with setProfile!\ncamera::Union{Nothing,camera}: Camera coordinates (α,β) corresponding to each ring used to generate images and in raytracing, see camera struct\nsubModelStartInds::Vector{Int}: Indices of start of each submodel in list of rings; used to separate out submodels for raytracing or for the recovery of individual models after being combined\n\nConstructors\n\nmodel(rings::Vector{ring}, profiles::Union{Nothing,Dict{Symbol,profile}}, camera::Union{Nothing,camera}, subModelStartInds::Vector{Int}) \n\nthe most flexible constructor, takes in user supplied vector of ring objects, optional dictionary of profiles, optional camera coordinates, and vector of indices for submodels\n\nmodel(rings::Vector{ring{Vector{Float64},Float64}})\n\ncloud model constructor, takes in a vector of ring objects that are each points in space and returns a model object with camera coordinates calculated from the physical parameters of each ring\n\nmodel(rMin::Float64, rMax::Float64, i::Float64, nr::Int, nϕ::Int, I::Function, v::Function, scale::Symbol; kwargs...)\n\ndisk-wind model constructor, takes in minimum and maximum radius, inclination angle, number of radial and azimuthal bins, intensity and velocity functions, and scale for radial binning; returns a model object with rings generated from these parameters\n\nmodel(r̄::Float64, rFac::Float64, Sα::Float64, i::Float64, nr::Int, nϕ::Int, scale::Symbol; kwargs...)\n\ndisk-wind model constructor, takes in average radius, radius scaling factor, power law for source function, inclination angle, number of radial and azimuthal bins, and scale for radial binning; returns a model object with rings generated from these parameters\n\n\n\n\n\n","category":"type"},{"location":"api/#BroadLineRegions.profile","page":"API","title":"BroadLineRegions.profile","text":"profile\n\nA struct to hold binned data, usually bound to model struct with profiles.jl#setProfile!.\n\nFields\n\nname::Symbol: Name of profile\nbinCenters::Vector{Float64}: Bin centers \nbinEdges::Vector{Float64}: Bin edges\nbinSums::Vector{Float64}: Sum of values in each bin (crude integral over bin)\n\n\n\n\n\n","category":"type"},{"location":"api/#BroadLineRegions.ring","page":"API","title":"BroadLineRegions.ring","text":"ring{V,F} <: AbstractRing{V,F}\n\nA mutable structure to hold parameters of each model ring, where the \"ring\" is a circle in the camera plane observing the BLR.\n\nFields\n\nr: Distance from central mass (in terms of r_s)\nUnion{Vector{Float64}, Float64, Function}\nCan be a single value for constant radius, or vector corresponding to azimuthal angles\nCan be a function returning Vector{Float64} or Float64\ni: Inclination angle in radians\nUnion{Vector{Float64}, Float64}\nMust be between 0 and pi2, with 0 being face-on and pi2 being edge-on\nrot: Rotation of system plane about z-axis in radians\nUnion{Vector{Float64}, Float64}\nθₒ: Opening angle of ring in radians\nUnion{Vector{Float64}, Float64}\nShould be between 0 and pi2\nv: Line of sight velocity\nUnion{Vector{Float64}, Float64, Function}\nCan be a function that calculates velocity from other parameters\nI: Intensity\nUnion{Vector{Float64}, Float64, Matrix{Float64}, Function}\nCan be a function that calculates intensity from other parameters\nϕ: Azimuthal angle in radians\nUnion{Vector{Float64}, Float64}\nϕ₀: Initial azimuthal angle before rotation in radians\nUnion{Vector{Float64}, Float64}\nDefaults to 0.0 if not provided or if rot is 0.0\nΔA: Projected area of each ring element in image\nUnion{Vector{Float64}, Float64}\nUsed in calculating profiles\nreflect: Whether cloud is reflected across disk mid-plane\nUnion{Bool, Array{Bool,}}\nτ: Optical depth\nUnion{Vector{Float64}, Float64, Function}\nη: Response parameter for reverberation\nUnion{Vector{Float64}, Float64, Function}\nΔr: Distance between camera pixels in r\nFloat64\nΔϕ: Distance between camera pixels in ϕ\nFloat64\nscale: Encoding for camera ring scaling\nUnion{Nothing, Symbol}\n:log or :linear scale\n\nConstructor\n\nring(; r, i, v, I, ϕ, rot=0.0, θₒ=0.0, ϕ₀=0.0, ΔA=1.0, reflect=false, \n    τ=0.0, η=1.0, Δr=1.0, Δϕ=1.0, scale=nothing, kwargs...)\n\nRequired parameters:\n\nr, i, v, I, ϕ\n\nOptional parameters with defaults:\n\nrot=0.0, θₒ=0.0, ϕ₀=0.0, ΔA=1.0, reflect=false, τ=0.0, η=1.0, Δr=1.0, Δϕ=1.0, scale=nothing\n\nAdditional keyword arguments are passed to the r, v, I, and τ functions if they are provided as functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#BroadLineRegions.drawCloud-Tuple{}","page":"API","title":"BroadLineRegions.drawCloud","text":"drawCloud(;μ::Float64=500.,β::Float64=1.0,F::Float64=0.5,\n        ϕ₀::Float64=0.0,i::Float64=π/4,rot::Float64=0.0,rₛ::Float64=1.0,\n        θₒ::Float64=0.0,θₒSystem::Float64=0.0,I::Union{Function,Float64}=IsotropicIntensity,\n        v::Union{Function,Float64}=vCircularCloud,ξ::Float64=1.0,\n        rng::AbstractRNG=Random.GLOBAL_RNG,kwargs...)\n\nGenerates a model ring struct for a single cloud drawn from a thick disk-like structure with parameters defined by the input arguments similar to Pancoast+ 2011 and 2014.\n\nArguments:\n\nμ::Float64=500.: Mean radius of model (in terms of r_s)\nβ::Float64=1.0: Shape parameter for radial distribution\nF::Float64=0.5: Beginning radius in units of μ where clouds can be placed. \nϕ₀::Float64=0.0: Initial azimuthal angle of cloud (rad) \ni::Float64=π/4: Inclination angle (rad) \nrot::Float64=0.0: Random rotation of cloud about z axis (rad) \nrₛ::Float64=1.0: Scale radius (in terms of r_s)\nθₒ::Float64=0.0: Opening angle of cloud (rad) \nθₒSystem::Float64=0.0: Maximum opening angle of the system (rad) \nξ::Float64=1.0: Fraction of clouds in back side that have not been moved to the front (when ξ = 1.0 clouds equally distributed front - back and when ξ = 0.0 all clouds are on the front side) \nI::Union{Function,Float64}=IsotropicIntensity: Intensity function/value\nv::Union{Function,Float64}=vCircularCloud: Velocity function/value\nkwargs...: Extra keyword arguments for I and v functions (see examples)\n\nReturns:\n\nA model ring struct representing the properties of the cloud. \n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getG-Tuple{Float64}","page":"API","title":"BroadLineRegions.getG","text":"getG(β::Float64)\n\nReturns a Gamma distribution with parameters derived from the input parameter β as in Pancoast+ 2014 equation 12.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getGamma-Tuple{}","page":"API","title":"BroadLineRegions.getGamma","text":"getGamma(;μ::Float64,β::Float64,F::Float64)\n\nReturns a Gamma distribution with parameters derived from the input parameters as in Pancoast+ 2014 equations 7-10.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getR","page":"API","title":"BroadLineRegions.getR","text":"getR(rₛ::Float64,γ::Gamma{Float64},rng::AbstractRNG=Random.GLOBAL_RNG)\n\nReturns a random number drawn from the Gamma distribution γ and shifted by rₛ.\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.getR-2","page":"API","title":"BroadLineRegions.getR","text":"getR(rₛ::Float64,μ::Float64,β::Float64,F::Float64,\n    g::Gamma{Float64},rng::AbstractRNG=Random.GLOBAL_RNG)\n\nReturns the radius r calculated using Pancoast+ 2014 equation 12, where g is a Gamma distribution and a random number is drawn from it.\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.getR-NTuple{5, Float64}","page":"API","title":"BroadLineRegions.getR","text":"getR(rₛ::Float64,μ::Float64,β::Float64,F::Float64,g::Float64)\n\nReturns the radius r calculated using Pancoast+ 2014 equation 12, where g is already set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Tuple{BroadLineRegions.model, BroadLineRegions.model}","page":"API","title":"Base.:+","text":"Base.:+(m1::model, m2::model) combines two models by concatenating their rings and camera parameters.\n\nCreate a new model with the combined rings and camera parameters, and updates the subModelStartInds accordingly.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{BroadLineRegions.model, Int64}","page":"API","title":"Base.getindex","text":"Base.getindex(m::model, i::Int)\n\nRetrieves the i-th submodel from the model m.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.DiskWindIntensity-Tuple{}","page":"API","title":"BroadLineRegions.DiskWindIntensity","text":"DiskWindIntensity(;r::Union{Vector{Float64},Float64}, i::Float64, ϕ::Union{Vector{Float64},Float64}, \n        f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64, rMin::Float64 = 0.0, rMax::Float64 = Inf, _...)\n\nCalculates the intensity from a disk-wind model of the BLR following the prescription given in Long+ 2023 and 2025, similar to Chiang and Murray 1996 and 1997, assumes optically thick line emission limit (Sobolev).\n\nArguments:\n\nr::Union{Vector{Float64},Float64} - radius from central mass (in terms of rₛ)\ni::Float64 - inclination angle (rad)\nϕ::Union{Vector{Float64},Float64} - list of azimuthal angles (rad)\nf1::Float64 - strength of radial velocity gradient mathrmdv_rmathrmdr\nf2::Float64 - strength of Keplerian shear velocity gradient mathrmdv_phimathrmdr\nf3::Float64 - strength of radial lifting velocity gradient mathrmdv_thetamathrmdr\nf4::Float64 - strength of vertical lifting velocity gradient mathrmdv_thetamathrmdtheta (equivalent to isotropic emission)\nα::Float64 - power-law index of the source function S(r) propto r^-alpha\nrMin::Float64 - minimum radius to consider (default: 0.0)\nrMax::Float64 - maximum radius to consider (default: Inf)\n\nReturns:\n\nintensity (arbitrary units) as a Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.DiskWind_I_-NTuple{8, Float64}","page":"API","title":"BroadLineRegions.DiskWind_I_","text":"DiskWind_I_(r::Float64, ϕ::Float64, i::Float64, f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64)\n\nSame as DiskWind_I_(r::Vector{Float64}, ϕ::Vector{Float64}, i::Float64, f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64) but for a single radius r and a single azimuthal angle ϕ.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.DiskWind_I_-Tuple{Float64, Vector{Float64}, Vararg{Float64, 6}}","page":"API","title":"BroadLineRegions.DiskWind_I_","text":"DiskWind_I_(r::Float64, ϕ::Vector{Float64}, i::Float64, f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64)\n\nSame as DiskWind_I_(r::Vector{Float64}, ϕ::Vector{Float64}, i::Float64, f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64) but for a single radius r and a vector of azimuthal angles ϕ.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.DiskWind_I_-Tuple{Vector{Float64}, Vararg{Float64, 7}}","page":"API","title":"BroadLineRegions.DiskWind_I_","text":"DiskWind_I_(r::Vector{Float64}, ϕ::Float64, i::Float64, f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64)\n\nSame as DiskWind_I_(r::Vector{Float64}, ϕ::Vector{Float64}, i::Float64, f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64) but for a vector of radii r and a single azimuthal angle ϕ.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.DiskWind_I_-Tuple{Vector{Float64}, Vector{Float64}, Vararg{Float64, 6}}","page":"API","title":"BroadLineRegions.DiskWind_I_","text":"DiskWind_I_(r::Vector{Float64}, ϕ::Vector{Float64}, i::Float64, f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64)\n\nCalculates the intensity of the disk wind at radius r from the central mass and inclined at angle i (rad) over grid of azimuthal angles ϕ (rad)     Follows the prescription given in Long+ 2023 and 2025, similar to Chiang and Murray 1996 and 1997, assumes optically thick line emission limit\n\nArguments:\n\nr::Vector{Float64} - radius from central mass (in terms of rₛ)\nϕ::Vector{Float64} - list of azimuthal angles (rad)\ni::Float64 - inclination angle (rad)\nf1::Float64 - strength of radial velocity gradient dvᵣ/dr\nf2::Float64 - strength of Keplerian shear dvϕ/dr\nf3::Float64 - strength of velocity gradient dvθ/dr\nf4::Float64 - strength of velocity gradient dvθ/dθ (or isotropic emission)\nα::Float64 - power-law index of the source function S(r) ∝ r^(-α)\n\nReturns:\n\nintensity (arbitrary units) as a Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.IsotropicIntensity-Tuple{}","page":"API","title":"BroadLineRegions.IsotropicIntensity","text":"IsotropicIntensity(;r::Union{Vector{Float64},Float64}, ϕ::Union{Vector{Float64},Float64}, \n        rescale::Float64=1.0, rMin::Float64 = 0.0, rMax::Float64 = Inf, _...)\n\nReturns a constant intensity value at all radii and azimuthal angles, rescaled by rescale factor.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.IϕCloudMask-Tuple{}","page":"API","title":"BroadLineRegions.IϕCloudMask","text":"IϕCloudMask(;r::Float64, ϕ::Float64, θₒ::Float64, ϕ₀::Float64, rot::Float64, i::Float64, κ::Float64=0.0, \n        ϕMin::Float64, ϕMax::Float64, overdense::Bool=false, _...)\n\nCalculates the intensity using cloudIntensity but with an extra layer of masking based on azimuthal angle ϕ and the specified range [ϕMin, ϕMax]. If ϕ is outside this range, the intensity is set to 0.0. If overdense is true, the intensity is multiplied by 2.0 to account for the \"lost\" cloud and thus preserve total intensity in the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.IϕDiskWindMask-Tuple{}","page":"API","title":"BroadLineRegions.IϕDiskWindMask","text":"IϕDiskWindMask(;r::Union{Vector{Float64},Float64}, ϕ::Union{Vector{Float64},Float64}, i::Float64, \n        f1::Float64, f2::Float64, f3::Float64, f4::Float64, α::Float64, ϕMin::Float64, ϕMax::Float64, _...)\n\nCalculates the intensity using DiskWindIntensity but with an extra layer of masking based on azimuthal angle ϕ and the specified range [ϕMin, ϕMax]. If ϕ is outside this range, the intensity is set to 0.0.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.cloudIntensity-Tuple{}","page":"API","title":"BroadLineRegions.cloudIntensity","text":"cloudIntensity(;r::Float64, ϕ::Float64, θₒ::Float64, ϕ₀::Float64, rot::Float64, i::Float64, κ::Float64=0.0, _...)\n\nCalculate the intensity of the cloud at radius r from the central mass and inclined at angle i (rad) over grid of azimuthal angles ϕ (rad) following Pancoast+ 2011 and 2014.\n\nArguments\n\nr::Float64: radius from central mass (in terms of r₍ₛ₎)\nϕ::Float64: azimuthal angle (rad)\nθₒ::Float64: opening angle of cloud\nϕ₀::Float64: initial azimuthal angle\nrot::Float64: rotation angle\ni::Float64: inclination angle\nκ::Float64: anisotropy parameter\n\nReturns\n\nIntensity (arbitrary units) as a Float64\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.vCirc","page":"API","title":"BroadLineRegions.vCirc","text":"vCirc(r::Float64, rₛ::Float64=1.0)\n\nCalculate circular velocity at radius r from central mass, with Schwarzschild radius rₛ.\n\nDefaults to rₛ=1.0 for unitless calculations.\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.vCircularCloud-Tuple{}","page":"API","title":"BroadLineRegions.vCircularCloud","text":"vCircularCloud(;r::Float64, ϕ₀::Float64, i::Float64, rot::Float64, θₒ::Float64, rₛ::Float64=1.0, reflect::Bool=false, _...)\n\nCalculate line of sight velocity for cloud in 3D space.\n\nArguments\n\nr::Float64: radius from central mass (in terms of rₛ)\nϕ₀::Float64: starting azimuthal angle in ring plane (rad)\ni::Float64: inclination angle of ring plane (rad)\nrot::Float64: rotation of system plane about z axis (rad)\nθₒ::Float64: opening angle of point\nrₛ::Float64=1.0: Schwarzschild radius (optional, to convert to physical units)\nreflect::Bool=false: whether the point is reflected across the midplane of the disk\n_...: extra kwargs, ignored\n\nReturns\n\nLine of sight velocity (Float64)\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.vCircularDisk-Tuple{}","page":"API","title":"BroadLineRegions.vCircularDisk","text":"vCircularDisk(;r::Union{Float64,Vector{Float64}}, i::Float64, ϕ::Union{Vector{Float64},Float64}, \n        θₒ::Union{Vector{Float64},Float64}, rₛ=1.0, _...)\n\nCalculate line of sight velocity for circular orbit at radius r from central mass and inclined at angle i (rad) over grid of azimuthal angles ϕ (rad).\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.vCircularRadialDisk-Tuple{}","page":"API","title":"BroadLineRegions.vCircularRadialDisk","text":"vCircularRadialDisk(;r::Union{Float64,Vector{Float64}}, i::Float64, ϕ::Union{Vector{Float64},Float64}, \n        vᵣFrac::Union{Vector{Float64},Float64}=0.0, inflow::Union{Vector{Bool},Bool}=true, rₛ=1.0, _...)\n\nCalculate line of sight velocity for circular orbit at radius r from central mass and inclined at angle i (rad) over grid of azimuthal angles ϕ (rad) with radial inflow/outflow.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.vCloudTurbulentEllipticalFlow-Tuple{}","page":"API","title":"BroadLineRegions.vCloudTurbulentEllipticalFlow","text":"vCloudTurbulentEllipticalFlow(;σρᵣ::Float64, σρc::Float64, σΘᵣ::Float64, σΘc::Float64, \n        θₑ::Float64, fEllipse::Float64, fFlow::Float64, σₜ::Float64, r::Float64, \n        i::Float64, rot::Float64, θₒ::Float64, rₛ::Float64=1.0, ϕ₀::Float64=0.0, \n        reflect::Bool=false, rng::AbstractRNG=Random.GLOBAL_RNG, _...)\n\nCalculate line of sight velocity for cloud in 3D space with potential for elliptical orbital velocities, in/outflow, and turbulence as in Pancoast+14.\n\nArguments\n\nσρᵣ::Float64: Radial standard deviation around radial orbits\nσρc::Float64: Radial standard deviation around circular orbits\nσΘᵣ::Float64: Angular standard deviation around radial orbits\nσΘc::Float64: Angular standard deviation around circular orbits\nθₑ::Float64: Angle in vϕ-vr plane\nfEllipse::Float64: Fraction of elliptical orbits\nfFlow::Float64: If < 0.5, inflow, otherwise, outflow\nσₜ::Float64: Standard deviation of turbulent velocity \nr::Float64: Radius from central mass (in terms of rₛ)\ni::Float64: Inclination angle of ring plane (rad)\nrot::Float64: Rotation of system plane about z axis (rad)\nθₒ::Float64: Opening angle of point\nrₛ::Float64=1.0: Schwarzschild radius (optional, to convert to physical units)\nϕ₀::Float64=0.0: Starting azimuthal angle in ring plane (rad)\nreflect::Bool=false: Whether the point is reflected across the midplane of the disk\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\n_...: Extra kwargs, ignored\n\nReturns\n\nLine of sight velocity (Float64)\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.binModel","page":"API","title":"BroadLineRegions.binModel","text":"binModel(bins::Union{Int,Vector{Float64}}=100; m::model, yVariable::Union{String,Symbol,Function}, \n        xVariable::Union{String,Symbol,Function}=:v, kwargs...)\nbinModel(bins::Vector{Float64}, dx::Array{Float64,}; m::model, yVariable::Union{String,Symbol,Function}, \n        xVariable::Union{String,Symbol,Function}=:v, kwargs...)\n\nBin the model into a histogram, where each bin is the integrated value of the yVariable as a function of the xVariable.\n\nArguments\n\nm::model: Model object to bin\nyVariable::Union{String,Symbol,Function}: Variable to bin\nMust be valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nbins::Union{Int,Vector{Float64}}: Number of bins or bin edges for binning\nIf Int: Number of bins with edges equally spaced between min/max of xVariable\nIf Vector{Float64}: Specific bin edges, with number of bins = length(bins)-1\nLeft edge inclusive, right edge exclusive (except last bin which is inclusive)\nxVariable::Union{String,Symbol,Function}=:v: Variable to bin over\nMust be a valid attribute of model.rings or a function that can be applied to model.rings\ndx::Array{Float64,}: Integration element for each bin\nIf provided, used as the associated integral element\nOtherwise defaults to ΔA in each ring struct\n\nReturns\n\nTuple{Vector{Float64},Vector{Float64},Vector{Float64}}: A tuple containing:\nbinEdges: Bin edges for the xVariable of the histogram\nbinCenters: Bin centers for the xVariable\nyBinned: Binned values of the yVariables\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.binnedSum-Tuple{Array{Float64}, Array{Float64}}","page":"API","title":"BroadLineRegions.binnedSum","text":"binnedSum(x::Array{Float64,}, y::Array{Float64, }; bins=100, \n        overflow=false, centered=false, minX=nothing, maxX=nothing)\n\nBin the x and y variables into a histogram, where each bin is the sum of the y values for the corresponding x values.\n\nArguments\n\nx::Array{Float64,}: x variable to bin over\ny::Array{Float64,}: y variable to bin\nbins::Union{Int,Vector{Float64}}=100: Number of bins or bin edges for binning\nIf Int: Number of bins with edges equally spaced between min/max of x\nIf Vector{Float64}: Specific bin edges, with number of bins = length(bins)-1\nLeft edge inclusive, right edge exclusive (except last bin which is inclusive)\noverflow::Bool=false: If true, include values outside bin range in the first/last bins\ncentered::Bool=false: If true, shift bin edges to center around middle value\nminX::Union{Float64,Nothing}=nothing: Minimum value of x for binning (defaults to minimum(x))\nmaxX::Union{Float64,Nothing}=nothing: Maximum value of x for binning (defaults to maximum(x))\n\nReturns\n\nTuple{Vector{Float64},Vector{Float64},Vector{Float64}}: A tuple containing:\nbinEdges: Bin edges for the x variable\nbinCenters: Bin centers for the x variable\nresult: Binned sums of the y variable\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getProfile-Tuple{BroadLineRegions.model, Union{Function, String, Symbol}}","page":"API","title":"BroadLineRegions.getProfile","text":"getProfile(m::model, name::Union{String,Symbol,Function}; \n           bins::Union{Int,Vector{Float64}}=100, \n           dx::Union{Array{Float64,},Nothing}=nothing, kwargs...)\n\nReturn a profile for the model based on the specified name.\n\nArguments\n\nm: Model object to get the profile from\nname: Name of the profile to get. Options include:\n:line: Returns the line profile (integrated intensity as function of velocity)\n:delay: Returns the delay profile (mean delays weighted by intensity/responsivity vs. velocity)\n:r: Returns the mean radius (weighted by intensity) as function of velocity \n:ϕ: Returns the mean azimuthal angle (weighted by intensity) as function of velocity\n:phase: Returns the phase profile (integrated phase as function of velocity)\nRequires U [Mλ], V [Mλ], PA [rad], and BLRAng [rad] as keyword arguments\nFunction: Returns the intensity weighted mean of this function vs. velocity\nbins: Number of bins or bin edges for binning\nIf Int: Number of bins with edges equally spaced between min/max velocity\nIf Vector{Float64}: Specific bin edges, with number of bins = length(bins)-1\nLeft edge inclusive, right edge exclusive (except last bin which is inclusive)\ndx: Integration element for each ring (defaults to ΔA in each ring struct if nothing)\nAdditional kwargs passed to binModel include:\noverflow=true: Include overflow bins\ncentered=true: Center bins around 0.0\nminX, maxX: Set min/max bin boundaries\n\nReturns\n\nprofile: A profile object containing bin edges, bin centers, and binned sums. Assign to a model object using setProfile! to store the profile in the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.phase-Tuple{BroadLineRegions.model}","page":"API","title":"BroadLineRegions.phase","text":"phase(m::model; U, V, PA, BLRAng, returnAvg=false, offAxisInds=nothing, kwargs...)\n\nCalculate differential phase signal for a model based on specified baselines, model orientation, and BLR angular size.\n\nArguments\n\nm::model: Model object to calculate phase for\nU::Vector{Float64}: U component of complex visibility in [Mλ]\nV::Vector{Float64}: V component of complex visibility in [Mλ]\nPA::Float64: On-sky position angle of the model in radians\nBLRAng::Float64: Characteristic size of the BLR model in radians (conversion from r_s to radians)\nreturnAvg::Bool=false: If true, returns the average phase across all baselines\noffAxisInds::Union{Nothing,Vector{Int}}=nothing: If provided, only calculates phase for baselines at specified indices\n\nReturns\n\nIf returnAvg=true: Tuple{Vector{Float64},Vector{Float64},Vector{Float64}} containing:\nBin edges for velocity\nBin centers for velocity\nAverage differential phase (in radians)\nIf returnAvg=false: Vector{Tuple{Vector{Float64},Vector{Float64},Vector{Float64}}} containing:\nFor each baseline, a tuple of bin edges, bin centers, and differential phase\n\nThe differential phase is calculated by integrating the phase over the model at each velocity bin, weighted by the intensity and area of each ring element.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.setProfile!-Tuple{BroadLineRegions.model, profile}","page":"API","title":"BroadLineRegions.setProfile!","text":"setProfile!(m::model, p::profile; overwrite::Bool=false)\n\nSet a profile in the model's profiles dictionary. If the profile already exists and overwrite is false, a warning is issued.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.t-Tuple{BroadLineRegions.ring}","page":"API","title":"BroadLineRegions.t","text":"tDisk(ring::ring; kwargs...)\n\nCalculate time delays for a point in a disk as t = eta r left(1 + cos(phi) sin(i)right).\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getΨ-Tuple{BroadLineRegions.model, Array{Float64}, Array{Float64}}","page":"API","title":"BroadLineRegions.getΨ","text":"getΨ(m::model,vEdges::Array{Float64},tEdges::Array{Float64})\n\nCalculate the 2D transfer function Ψ for a model m over specified velocity and time bins, whose edges are given by vEdges and tEdges.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getΨ-Tuple{BroadLineRegions.model, Int64, Int64}","page":"API","title":"BroadLineRegions.getΨ","text":"getΨ(m::model,vBins::Int64,tBins::Int64)\n\nCalculate the 2D transfer function Ψ for a model m over specified number of velocity bins vBins and time bins tBins. The velocity and time edges are automatically calculated based on the minimum and maximum values for velocity and delays in the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getΨt","page":"API","title":"BroadLineRegions.getΨt","text":"getΨt(m::model,tEdges::Array{Float64},overflow::Bool=false;)\n\nCalculate the 1D transfer function Ψ(t) for a model m over specified time edges tEdges. The overflow parameter determines whether to include contributions from delays outside the specified edges in the edge bins.\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.getΨt-2","page":"API","title":"BroadLineRegions.getΨt","text":"getΨt(m::model,tBins::Int64,maxT::Float64=Inf,overflow::Bool=false)\n\nCalculate the 1D transfer function Ψ(t) for a model m over specified number of time bins tBins. The maxT parameter specifies the maximum time delay to consider, and overflow determines whether to include contributions from delays outside the specified edges in the edge bins.\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.response-Tuple{Float64}","page":"API","title":"BroadLineRegions.response","text":"response(r::Float64; ηₒ::Float64=0.5, η₁::Float64=0.5, αRM::Float64=0.0, rNorm::Float64=1.0, _...)\n\nCalculate response function for use in reverberation mapping calculations.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.photograph","page":"API","title":"BroadLineRegions.photograph","text":"photograph(r::Float64, ϕ₀::Float64, i::Float64, rot::Float64, θₒ::Float64, reflect::Bool=false)\n\nCalculate the image coordinates from system coordinates r, ϕ + inclination angle i.\n\nArguments\n\nr::Float64: radius from central mass (in terms of rₛ)\nϕ₀::Float64: unrotated azimuthal angle in ring plane (rad)\ni::Float64: inclination angle of ring plane (rad)\nrot::Float64: rotation of system plane about z axis (rad)\nθₒ::Float64: ring opening angle\nreflect::Bool=false: whether the point is reflected across the midplane of the disk\n\nReturns\n\nα::Float64: image x coordinate (in terms of rₛ)\nβ::Float64: image y coordinate (in terms of rₛ)\n\nNote\n\nThis function is coordinate photography only. To visualize models, see Image.`\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.raytrace!-Tuple{BroadLineRegions.model}","page":"API","title":"BroadLineRegions.raytrace!","text":"raytrace!(m::model; IRatios::Union{Float64,Array{Float64,}}=1.0, \n        τCutOff::Float64=1.0, raytraceFreeClouds::Bool=false)\n\nPerform raytracing for a model, combining overlapping components along line of sight.\n\nwarning: Slow\nThis function not very performant and can take a long time to combine large models. Consider using removeDiskObscuredClouds! for simple disk obscuration removal if you do not need full raytracing.\n\nThis function should be called after combining all relevant models (i.e. mCombined = m1 + m2 + m3...). It performs raytracing in discrete steps (no absorption, only adding intensity in chunks along  the line of sight until maximum optical depth τ is reached) and generates a new model object  with extraneous points removed. Note that this function will mutate the input model objects.\n\nArguments\n\nm::model: Model to raytrace\nIRatios::Union{Float64,Array{Float64,}}=1.0: Intensity ratios for each submodel\nIf Float64, applies to all submodels equally\nIf array, applies to each submodel individually (must match number of submodels)\nUsed when combining models with different intensity functions if they aren't properly normalized\nτCutOff::Float64=1.0: Maximum optical depth to raytrace to (stops when τ > τCutOff)\nraytraceFreeClouds::Bool=false: Whether to raytrace free clouds (cloud-cloud raytracing)\nIf false, clouds are only raytraced if they overlap with a continuous model\nIf true, clouds will be checked for overlap with other clouds and raytraced accordingly\n\nReturns\n\nm::model: Model with raytraced points\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.raytrace-NTuple{5, Float64}","page":"API","title":"BroadLineRegions.raytrace","text":"raytrace(α::Float64, β::Float64, i::Float64, rot::Float64, θₒPoint::Float64)\n\nCalculate where ray traced back from camera coordinates α and β intersects the system (assumes circular geometry).\n\nArguments\n\nα::Float64: image x coordinate (in terms of rₛ)\nβ::Float64: image y coordinate (in terms of rₛ)\ni::Float64: inclination angle of system (rad)\nrot::Float64: how the point was rotated about z axis (rad)\nθₒPoint::Float64: opening angle of current point\n\nReturns\n\nr::Float64: distance from central mass (in terms of rₛ)\nϕ::Float64: azimuthal angle of system ring plane at intersection\nϕ₀::Float64: original azimuthal angle in ring plane (no rotation)\n\nNote\n\nThis function is coordinate raytracing only. To raytrace models and combine intensities, see raytrace!. \n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.raytrace-Tuple{Float64, Float64, Float64, Float64, Float64, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Vector{Float64}}","page":"API","title":"BroadLineRegions.raytrace","text":"raytrace(α::Float64, β::Float64, i::Float64, rot::Float64, θₒPoint::Float64, \n        r3D::Matrix{Float64}, xyz::Vector{Float64}, matBuff::Matrix{Float64}, \n        colBuff::Vector{Float64})\n\nPerformant version of raytrace function – calculate where ray traced back from camera coordinates α, β intersects the system (assumes circular geometry).\n\nArguments\n\nα::Float64: image x coordinate (in terms of rₛ)\nβ::Float64: image y coordinate (in terms of rₛ)\ni::Float64: inclination angle of system (rad)\nrot::Float64: rotation of current point about z axis (rad)\nθₒPoint::Float64: opening angle of current point\nr3D::Matrix{Float64}: matrix that rotates system plane into XY plane\nxyz::Vector{Float64}: preallocated xyz vector (but not precalculated)\nmatBuff::Matrix{Float64}: preallocated buffer matrix for storing result of 3x3 matrix multiplication\ncolBuff::Vector{Float64}: preallocated buffer vector for storing final matrix multiplication result\n\nReturns\n\nr::Float64: distance from central mass (in terms of rₛ)\nϕ::Float64: azimuthal angle of system ring plane at intersection\nϕ₀::Float64: original azimuthal angle in ring plane\n\nNote\n\nThis function is coordinate raytracing only. To raytrace models and combine intensities, see raytrace!. \n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.removeDiskObscuredClouds!","page":"API","title":"BroadLineRegions.removeDiskObscuredClouds!","text":"removeDiskObscuredClouds!(m::model, rotate3D::Function=rotate3D)\n\nRemove clouds that are obscured by the disk.\n\nPerforms simple raytracing for an optically thick obscuring disk. The function modifies the input model by removing cloud points that are obscured by the disk. Note that this is a mutating operation and the input model will be modified in place.\n\nArguments\n\nm::model: Model to remove disk obscured clouds. Should be a combined model consisting  of a disk component and a cloud component.\nrotate3D::Function=rotate3D: Function to rotate coordinates in 3D space\n\nReturns\n\nm::model: Model with disk obscured clouds removed\n\nSee also\n\nzeroDiskObscuredClouds!: Function to zero out disk obscured clouds instead of removing them\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.zeroDiskObscuredClouds!-Tuple{BroadLineRegions.model}","page":"API","title":"BroadLineRegions.zeroDiskObscuredClouds!","text":"zeroDiskObscuredClouds!(m::model; diskCloudIntensityRatio::Float64=1.0, rotate3D::Function=rotate3D)\n\nZero out the intensities of clouds that are obscured by the disk.\n\nPerforms simple raytracing for an optically thick obscuring disk. The function modifies the input model by setting the intensity of obscured cloud points to zero and adjusting the disk intensity according to the specified ratio.\n\nArguments\n\nm::model: Model to zero out disk obscured clouds. Should be a combined model consisting of a disk component and a cloud component. \ndiskCloudIntensityRatio::Float64=1.0: Ratio of disk to cloud intensity, used to scale  the disk intensities after zeroing out clouds\nrotate3D::Function=rotate3D: Function to rotate coordinates in 3D space\n\nReturns\n\nm::model: Model with disk obscured clouds zeroed out\n\nSee also\n\nremoveDiskObscuredClouds!: Function to remove disk obscured clouds instead of zeroing them out\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.addGrid!","page":"API","title":"BroadLineRegions.addGrid!","text":"addGrid!(m::model, colors=nothing, nϕ::Int=64)\n\nAdd a grid to the model image plot - mostly a debugging tool to visualize grid cells of overlapping models.\n\nArguments\n\nm::model: Model object to add grid to\ncolors=nothing: Vector of colors for each submodel (if nothing, uses default colors)\nnϕ::Int=64: Number of azimuthal angles to use for the grid\n\nReturns\n\n::Plots.plot: Plot with grid added\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.getFlattenedCameraIndices-Tuple{BroadLineRegions.model}","page":"API","title":"BroadLineRegions.getFlattenedCameraIndices","text":"getFlattenedCameraIndices(m::model)\n\nGet flattened camera indices corresponding to rings in model.\n\nArguments\n\nm::model: Model object to extract camera indices from\n\nReturns\n\ncamStartInds::Vector{Int}: Vector of camera starting indices with length equal to m.subModelStartInds\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getRingFromFlattenedInd-Tuple{BroadLineRegions.model, Int64}","page":"API","title":"BroadLineRegions.getRingFromFlattenedInd","text":"getRingFromFlattenedInd(m::model, flattenedInd::Int) -> Tuple{Int, Int}\n\nRetrieve the model ring index and subindex (if applicable) from flattened array index.\n\nArguments\n\nm::model: Model object with rings \nflattenedInd::Int: The index in the flattened array we need to work back from\n\nReturns\n\nrow::Int: The ring index in model.rings that the flattened index corresponds to\ncolumn::Int: The subindex that matches the flattened index passed to this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getVariable-Tuple{BroadLineRegions.model, Function}","page":"API","title":"BroadLineRegions.getVariable","text":"getVariable(m::model, variable::Function; flatten=false)\n\nRetrieve model variable when specified as a Function. See main docstring for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getVariable-Tuple{BroadLineRegions.model, String}","page":"API","title":"BroadLineRegions.getVariable","text":"getVariable(m::model, variable::Union{String,Symbol,Function}; flatten=false)\n\nRetrieve elements from model object and stack them into matrices for easy manipulation.\n\nArguments\n\nm::model: Model object to extract variables from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nflatten::Bool=false: If true, flatten the result to a vector\n\nReturns\n\nArray{Float64,}: Matrix or vector of extracted variable from model.rings, created by stacking the output variable for each ring\nFor example, if variable given is :I, result will have shape (length(r), length(ϕ)) as at each r and ϕ there is a value of I\nIf flatten=true, result will be a flattened vector\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.getVariable-Tuple{BroadLineRegions.model, Symbol}","page":"API","title":"BroadLineRegions.getVariable","text":"getVariable(m::model, variable::Symbol; flatten=false)\n\nRetrieve model variable when specified as a Symbol. See main docstring for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.get_r3D-Tuple{Any, Any, Any}","page":"API","title":"BroadLineRegions.get_r3D","text":"get_r3D(i::Float64, rot::Float64, θₒ::Float64) -> Matrix{Float64}\n\nCalculate rotation matrix to transform from initial XY plane coordinates to 3D space.\n\nParameters\n\ni::Float64: Inclination angle of ring (rad)\nrot::Float64: Rotation of ring plane about z axis (rad)\nθₒ::Float64: Opening angle of point (rad)\n\nReturns\n\nmatrix::Matrix{Float64}: 3×3 rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.get_rMinMaxDiskWind-Tuple{Float64, Float64, Float64}","page":"API","title":"BroadLineRegions.get_rMinMaxDiskWind","text":"get_rMinMaxDiskWind(r̄::Float64, rFac::Float64, α::Float64)\n\nCalculate the minimum and maximum radius of model given the (intensity weighted) mean radius r̄,  the radius factor rFac, and the power-law index α following Long+ 2023.\n\nParameters\n\nr̄::Float64: mean radius of model (in terms of rₛ)\nrFac::Float64: radius scaling factor \nα::Float64: power-law index of the source function S(r) propto r^-alpha (cannot be 1/2 or 3/2 as this divides by zero)\n\nReturns\n\nrMin::Float64: minimum radius of model (in terms of rₛ)\nrMax::Float64: maximum radius of model (in terms of rₛ)\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.image!-Tuple","page":"API","title":"BroadLineRegions.image!","text":"BLR.image(m::model, variable::Union{String,Symbol,Function}, kwargs...)\n\nGenerate an image of the model where the color of each point is determined by the variable provided.\n\nArguments\n\nm::model: Model object to extract variable from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\n\nKeywords\n\nAdditional keyword arguments are passed to Plots.plot\n\nReturns\n\np::Plots.plot: Plot object representing the generated image\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.image!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"API","title":"BroadLineRegions.image!","text":"BLR.image(m::model, variable::Union{String,Symbol,Function}, kwargs...)\n\nGenerate an image of the model where the color of each point is determined by the variable provided.\n\nArguments\n\nm::model: Model object to extract variable from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\n\nKeywords\n\nAdditional keyword arguments are passed to Plots.plot\n\nReturns\n\np::Plots.plot: Plot object representing the generated image\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.image-Tuple","page":"API","title":"BroadLineRegions.image","text":"BLR.image(m::model, variable::Union{String,Symbol,Function}, kwargs...)\n\nGenerate an image of the model where the color of each point is determined by the variable provided.\n\nArguments\n\nm::model: Model object to extract variable from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\n\nKeywords\n\nAdditional keyword arguments are passed to Plots.plot\n\nReturns\n\np::Plots.plot: Plot object representing the generated image\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.plot3d!-Tuple","page":"API","title":"BroadLineRegions.plot3d!","text":"plot3d(m::model, [variable], [annotatedCamera], [kwargs...])\n\nGenerate a 3D plot of the model geometry, optionally colored by a variable.\n\nParameters\n\nm::model: Model object to plot\nvariable::Union{String,Symbol,Function}=nothing: Variable to color the points by\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g., :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nIf not provided, defaults to nothing (no coloring)\nannotatedCamera::Bool=true: Whether to annotate the camera position and orientation in the plot\nkwargs...: Additional keyword arguments passed to Plots.plot\n\nReturns\n\np::Plots.plot: 3D plot of the model geometry, optionally colored by the variable provided\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.plot3d!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"API","title":"BroadLineRegions.plot3d!","text":"plot3d(m::model, [variable], [annotatedCamera], [kwargs...])\n\nGenerate a 3D plot of the model geometry, optionally colored by a variable.\n\nParameters\n\nm::model: Model object to plot\nvariable::Union{String,Symbol,Function}=nothing: Variable to color the points by\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g., :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nIf not provided, defaults to nothing (no coloring)\nannotatedCamera::Bool=true: Whether to annotate the camera position and orientation in the plot\nkwargs...: Additional keyword arguments passed to Plots.plot\n\nReturns\n\np::Plots.plot: 3D plot of the model geometry, optionally colored by the variable provided\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.plot3d-Tuple","page":"API","title":"BroadLineRegions.plot3d","text":"plot3d(m::model, [variable], [annotatedCamera], [kwargs...])\n\nGenerate a 3D plot of the model geometry, optionally colored by a variable.\n\nParameters\n\nm::model: Model object to plot\nvariable::Union{String,Symbol,Function}=nothing: Variable to color the points by\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g., :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nIf not provided, defaults to nothing (no coloring)\nannotatedCamera::Bool=true: Whether to annotate the camera position and orientation in the plot\nkwargs...: Additional keyword arguments passed to Plots.plot\n\nReturns\n\np::Plots.plot: 3D plot of the model geometry, optionally colored by the variable provided\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.profile!-Tuple","page":"API","title":"BroadLineRegions.profile!","text":"profile(m::model, [variable], [kwargs...])\n\nPlot all profiles set in the model, normalized to the maximum value of each profile.\n\nArguments\n\nmodel: A model object containing profile data.\nvariable: Optional. A symbol or string (or list of symbols/strings) specifying which profile to plot. If not provided, all profiles set in model will be plotted.\nkwargs...: Additional keyword arguments passed to Plots.plot\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.profile!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"API","title":"BroadLineRegions.profile!","text":"profile(m::model, [variable], [kwargs...])\n\nPlot all profiles set in the model, normalized to the maximum value of each profile.\n\nArguments\n\nmodel: A model object containing profile data.\nvariable: Optional. A symbol or string (or list of symbols/strings) specifying which profile to plot. If not provided, all profiles set in model will be plotted.\nkwargs...: Additional keyword arguments passed to Plots.plot\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.reflect!-Tuple{Any, Any}","page":"API","title":"BroadLineRegions.reflect!","text":"reflect!(xyzSys::Vector{Float64}, i::Float64) -> Vector{Float64}\n\nReflect coordinates in 3D space across the ring plane.\n\nParameters\n\nxyzSys::Vector{Float64}: [x;y;z] coordinates in 3D space\ni::Float64}: Inclination angle of ring plane (rad)\n\nReturns\n\nxyzSys::Vector{Float64}: [x';y';z'] coordinates in 3D space after reflection\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.removeNaN!-Tuple{BroadLineRegions.model}","page":"API","title":"BroadLineRegions.removeNaN!","text":"removeNaN!(m::model)\n\nRemove points with I = NaN from model.\n\nParameters\n\nm::model: Model to remove points from\n\nReturns\n\nm::model: Model with NaN points removed\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.reset!-Tuple{BroadLineRegions.model}","page":"API","title":"BroadLineRegions.reset!","text":"reset!(m::model; profiles=true, img=false)\n\nErase existing profiles/raytrace status.\n\nParameters\n\nm::model: Model object to reset\nprofiles::Bool=true: If true, reset profiles\nimg::Bool=false: If true, reset raytracing boolean (does not change existing model but allows model to be raytraced again after combining other new models)\n\n\n\n\n\n","category":"method"},{"location":"api/#BroadLineRegions.rotate3D","page":"API","title":"BroadLineRegions.rotate3D","text":"rotate3D(r::Float64, ϕ₀::Float64, i::Float64, rot::Float64, θₒ::Float64, reflect::Bool=false)\n\nTransform from ring coordinates to 3D coordinates where camera is at +x.\n\nParameters\n\nr::Float64: Radius from central mass (in terms of rₛ)\nϕ₀::Float64: Starting azimuthal angle in ring plane (rad)\ni::Float64: Inclination angle of ring plane (rad)\nrot::Float64: Rotation of system plane about z axis (rad)\nθₒ::Float64: Opening angle of point (rad)\nreflect::Bool=false: Whether to reflect across the ring plane\n\nReturns\n\nTuple{Float64, Float64, Float64}: (x, y, z) coordinates in 3D space\n\n\n\n\n\n","category":"function"},{"location":"api/#BroadLineRegions.profile-Tuple","page":"API","title":"BroadLineRegions.profile","text":"profile(m::model, [variable], [kwargs...])\n\nPlot all profiles set in the model, normalized to the maximum value of each profile.\n\nArguments\n\nmodel: A model object containing profile data.\nvariable: Optional. A symbol or string (or list of symbols/strings) specifying which profile to plot. If not provided, all profiles set in model will be plotted.\nkwargs...: Additional keyword arguments passed to Plots.plot\n\n\n\n\n\n","category":"method"},{"location":"usage_examples/#Usage-and-Examples","page":"Usage and Examples","title":"Usage and Examples","text":"","category":"section"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"This guide explores a few more complicated tasks one might wish to use this code for. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Pages = [\"usage_examples.md\"]\nDepth = 2:3","category":"page"},{"location":"usage_examples/#Reproducing-the-line-profile-and-transfer-function-shown-in-[CM96](https://ui.adsabs.harvard.edu/abs/1996ApJ...466..704C/abstract)","page":"Usage and Examples","title":"Reproducing the line profile and transfer function shown in CM96","text":"","category":"section"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"CM96 showed that disk-wind models of the BLR could produce single-peaked line profiles, and as part of their results they generated a hypothetical 2D transfer function for a disk-wind BLR as applied to NGC 5548. We can reproduce such a map with just a few lines of code using BroadLineRegions.jl. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"note: Note\nBroadLineRegions.jl exports itself as both BroadLineRegions and the shorter BLR. We will use the shorter BLR throughout these examples but know that BLR is equivalent to BroadLineRegions should you prefer the longer version.","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"First, let's define the model using DiskWindModel: ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"using BroadLineRegions\nmCM96 = BLR.DiskWindModel(3000.,100.,1.,75/180*π,\n        nr=5096,nϕ=1024,scale=:log,f1=1.0,f2=1.0,f3=0.0,f4=0.0,\n        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,τ=5.0,reflect=false)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"We use the parameters from CM96 for barr = 3000rmr_s, r_rmfac = 10^2, alpha = 1, and i = 75^circ. CM96 considered the case of radial and Keplerian shear only, so we turn these gradients on by setting f_1 = 1 and f_2 = 1 (radial and Keplerian shear, respectively) and turn off the remaining velocity gradients by setting f_3 = 0 and f_4 = 0. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"To have a well sampled model grid we pick nr=5096 and nϕ=1024 with scale=:log, which will result in the returned model object having 5096 \"rings\" in our circular camera aperture with each ring holding 1024 grid cells evenly divided in phi space. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"While this is the default, for the sake of this demonstration we also set I=BLR.DiskWindIntensity to explicitly tell the model to use the intensity formulation first proposed in CM96 (and using the \"f\" parameter language introduced in Long+2023). We also tell the model to calculate the velocities according to the built in function BLR.vCircularDisk, which simply calculates the projected line of sight velocity as v = sqrtfracrmr_s2rsin i sinphi. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Finally, while not required, we set τ = 5.0 as we want our disk to be optically thick and reflect = false as we do not want to move any points from the back to the front. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Now that we have a model, let's get the line profile and store it in our model:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"p = BLR.getProfile(mCM96,:line,bins=101) #get the line profile using 101 bins in velocity-space, otherwise using default params\nBLR.setProfile!(mCM96,p) #store the line profile in our model structure","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"We can do a quick visualization with the built-in profile macro:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"BLR.profile(mCM96) #plot all profiles stored in model object, here we only have set :line so only :line will be plotted","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Which should return a plot like this (left panel, right panel is Figure 2 in CM96):","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"(Image: result of BLR.profile)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Note that the y-axis units are arbitrary and the x-axis is in units of velocity [c], not lambda as published in Fig 2 of CM96, but the shape clearly matches their result that the line profile for such a model should be single-peaked. This is also showing only the full model line profile (thei solid line), not the data or other models. We could reproduce their plot exactly by rescaling our flux and converting from velocity-space to wavelength space as well as plotting the data and a model line profile with azimuthally isotropic emission, but we will leave that as an exercise for the motivated reader...","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"It is similarly easy to use BroadLineRegions.jl to generate transfer functions for any user-defined model. In looking at Figure 4 of CM96 we see that their y-axis (delays) spans 0-20 days and the x-axis (projected velocity) -12-12 (10^8 rmcm rms^-1). To match our model result to theirs, we first need to convert our units of rmr_s to the more physical unit of days. CM96 used M_rmNGC5548 approx 10^8 rmM_odot, which means we can calculate the conversion factor as:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"M = 1e8*2e30 #kg\nrs = 2*M*6.67e-11/9e16 #2GM/c^2\nrsDay = rs/3e8/3600/24 #days","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"We only need to obtain the transfer function Psi over the range shown in CM96, so let's define the tEdges and vEdges we want to use to match their result and then generate the transfer function:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"tEdges = collect(range(0.0,stop=20.0/rsDay,length=101)) #will generate 100 bins, convert 20 days upper limit to units of rs\nvEdges = collect(range(-0.04,stop=0.04,length=101)) #0.04c ~12*1e8 cm/s\nΨ = BLR.getΨ(mCM96,vEdges,tEdges) #obtain transfer function with our supplied bin edges ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Note that in Fig. 4 of CM96 the edges between the colors are sharp, indicating that they used discrete bins in their image to better showcase structure. While these levels are not explicitly supplied in the paper, we can make a good guess that they are somewhat evenly spaced logarithmic bins. To transform our Psi to match their binning, we can do something like: ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"function getΨMatch(ΨBinned,levels=[-0.4*i for i=0:11]) #generate constant log10 bins of Ψ\n    #fills intervals that are closed at the top;\n    #that is, for regions z1 and z2 the filled region is z1 < Z <= z2\"\n\n    logΨ = log10.(ΨBinned)\n    res = zeros(size(logΨ))\n    mask = (logΨ .<= levels[2]) .& (logΨ .>= levels[1])\n    res[mask] .= (levels[1]+levels[2])/2\n    for i=2:length(levels)-1\n        mask = (logΨ .< levels[i]) .& (logΨ .>= levels[i+1])\n        res[mask] .= (levels[i]+levels[i+1])/2\n    end\n    mask = (logΨ .< levels[end])\n    res[mask] = logΨ[mask]\n    return res\nend\nΨDiscrete = getΨMatch(Ψ./maximum(Ψ)) #normalize and generate discrete bins","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"All that's left to do now is visualize the result, which we will do with the heatmap function from Julia's Plots.jl:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"using Plots\n\nheatmap(vEdges.*3e10/1e8,tEdges.*rsDay,ΨDiscrete',\n    ylims=(0,20),xlims=(-12,12),clims=(-4.4,0.0),cbar=false,\n    xlabel=\"v (10⁸ cm/s)\",ylabel=\"τ (days)\",minorticks=true,\n    tickdirection=:out,widen=false,size=(500,500))","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Which should return something like this (left plot, right plot is Fig 4. in CM96):","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"(Image: 2D Ψ map)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"While our binning is a little off/coarser than in CM96, this is clearly a pretty good match for a quick and dirty calculation. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"A few final notes: ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Note that when plotting we use ΨDiscrete' because heatmap expects the shape of the image variable to be flipped from how BroadLineRegions.jl calculates it (the shape of Ψ when returned is (number of velocity bins, number of t bins)). \nIf you wanted to generate just the 1D response function as shown in CM96 Figure 5, BroadLineRegions.jl has syntax for that too: tCenters, Ψt = BLR.getΨt(mCM96,101,10/rsDay). ","category":"page"},{"location":"usage_examples/#Reproducing-sample-cloud-model-results-from-[Pancoast2014](https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.3055P/abstract)","page":"Usage and Examples","title":"Reproducing sample cloud model results from Pancoast+2014","text":"","category":"section"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"We can also generate \"cloud\"/thick-disk models of the BLR similar to Pancoast+2014 easily with BroadLineRegions.jl. In this section we will reproduce part of Figure 4 in Pancoast+2014, which shows five different model BLRs and their 1D transfer functions with the following parameters: ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"parameter model 1 model 2\nr_rmmean [days] 4.0 4.0\nF 0.25 0.25\nbeta 1.0 0.8\ntheta_o [deg] 40 30\ni [deg] 20 20\nkappa -0.4 -0.4\ngamma 5.0 5.0\nxi 0.3 0.1\nf_rmellipse 0.0 1.0\nf_rmflow 0.0 -\ntheta_e [deg] 0.0 -\nsigma_rmturb 0.0 0.0","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"First, we initialize model structs for both of these cases:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"M = 10^(6.5)*2e30 #kg, from Pancoast+2014\nrs = 2*6.67e-11*M/9e16 #2GM/c^2, m\nrsDay = rs/3e8/3600/24 #days^C #days -- model expects μ in units of rₛ\nnClouds = 100_000 #small number of clouds just for demonstration\nmP1 = BLR.cloudModel(nClouds,μ=4/rsDay,F=0.25,β=1.0,θₒ=40/180*π,i=20/180*π,\n        κ=-0.4,γ=5.0,ξ=0.3,fEllipse=0.0,fFlow=0.0,θₑ=0.0,σₜ=0.0,\n        σρc=0.0,σΘᵣ=0.0,σΘc=0.0,σρᵣ=0.0,\n        I=BLR.cloudIntensity,v=BLR.vCloudTurbulentEllipticalFlow,τ=0.0)\nmP2 = BLR.cloudModel(nClouds,μ=4/rsDay,F=0.25,β=0.8,θₒ=30/180*π,i=20/180*π,\n        κ=-0.4,γ=5.0,ξ=0.1,fEllipse=1.0,σₜ=0.0,\n        fFlow=0.0,θₑ=0.0,σρc=0.0,σΘᵣ=0.0,σΘc=0.0,σρᵣ=0.0,\n        I=BLR.cloudIntensity,v=BLR.vCloudTurbulentEllipticalFlow,τ=0.0)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Where the first argument passed to cloudModel is the number of clouds to generate (here we use a relatively small number just for demonstration purposes), and the keyword arguments supplied mostly correspond to the values in the table above and are fully described in Pancoast+2014. The extra keyword arguments set to 0 but not in the table are options not used in this calculation, and the final line specifies that we would like the intensity calculated with the cloudIntensity function, the velocities calculated with vCloudTurbulentEllipticalFlow, and that the optical depth of the cloud is 0.","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"To compare to Figure 4 in Pancoast+2014 we can again generate transfer functions for both models:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"using Plots\n\nvEdges = collect(range(-0.015,stop=0.015,length=51)) #Δλ/λ ~ v/c\ntEdges = collect(range(0.0,stop=20.0/rsDay,length=51))\nΨ1 = BLR.getΨ(mP1,vEdges,tEdges)\nΨ2 = BLR.getΨ(mP2,vEdges,tEdges)\np1 = heatmap(vEdges.*3e5,tEdges.*rsDay,(Ψ1'./maximum(Ψ1)),ylims=(0,20),cbar=false,\n    xlabel=\"Δv (km/s)\",ylabel=\"Lag (days)\",minorticks=true,tickdirection=:out,\n    widen=false,size=(500,500),guidefontsize=18,tickfontsize=16)\np2 = heatmap(vEdges.*3e5,tEdges.*rsDay,(Ψ2'./maximum(Ψ2)),ylims=(0,20),cbar=false,\n    xlabel=\"Δv (km/s)\",ylabel=\"Lag (days)\",minorticks=true,tickdirection=:out,\n    widen=false,size=(500,500),guidefontsize=18,tickfontsize=16)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Which should produce something like the right column of plots in the comparison below (top plot = p1 and bottom = p2):","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"(Image: 2D cloud Ψ maps)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Note that again we are just trying to roughly match the color scale by eye, but the general shape and morphology looks good.","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"We can also quickly visualize the geometry of the system from any angle (i.e. to compare to the rightmost panel of Fig. 4 in Pancoast+2014) using the built-in plot3d macro:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"BLR.plot3d(mP1,:I,cam=(10,10)) #visualize the system with points colored by their intensity with a camera at 10 deg azimuth and altitude","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Iterating this over a wide variety of camera angles one can produce fun 3D visualizations of the BLR models like the gifs below:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"model 1 model 2\n(Image: gif of model 1 geometry) (Image: gif of model 2 geometry)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Comparing to the stills in Figure 4 of Pancoast+2014 again shows good agreement (note that in generating this animation the number of clouds was set to be just 2,000 to better show the structure/agreement with Pancoast+2014). ","category":"page"},{"location":"usage_examples/#Reproducing-the-line-and-phase-profiles-shown-in-[Long2023](https://dx.doi.org/10.3847/1538-4357/ace4bb)","page":"Usage and Examples","title":"Reproducing the line and phase profiles shown in Long+2023","text":"","category":"section"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"While reverberation mapping has historically been the primary way to constrain the properties of the BLR, advances in interferometry have recently allowed for the BLR to be directly \"imaged\" by GRAVITY on the VLTI, up to zsim 25! ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Here we will demonstrate how to generate line and phase profiles for model BLRs, reproducing the results shown in the left panel in Figure 2 of Long+2023 in the process. To start, we define disk-wind model objects for each case shown in the figure: ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"mLAll = BLR.DiskWindModel(8.5e3,50.,1.,45/180*π,nr=4096,nϕ=1024,\n        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=1.0,f2=1.0,\n        f3=1.0,f4=1.0,τ=5.,reflect=false)\nmLf1 = BLR.DiskWindModel(8.5e3.,50.,1.,45/180*π,nr=4096,nϕ=1024,\n        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=1.0,f2=0.0,\n        f3=0.0,f4=0.0,τ=5.,reflect=false)\nmLf2 = BLR.DiskWindModel(8.5e3,50.,1.,45/180*π,nr=4096,nϕ=1024,\n        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=0.0,f2=1.0,\n        f3=0.0,f4=0.0,τ=5.,reflect=false)\nmLf3 = BLR.DiskWindModel(8.5e3,50.,1.,45/180*π,nr=4096,nϕ=1024,\n        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=0.0,f2=0.0,\n        f3=1.0,f4=0.0,τ=5.,reflect=false)\nmLf4 = BLR.DiskWindModel(8.5e3,50.,1.,45/180*π,nr=4096,nϕ=1024,\n        I=BLR.DiskWindIntensity,v=BLR.vCircularDisk,f1=0.0,f2=0.0,\n        f3=0.0,f4=1.0,τ=5.,reflect=false)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Setting the values in DiskWindModel to approximately match those in the paper. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"We can then generate the line profiles for each just as we did in the CM96 example above:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"LPAll = BLR.getProfile(mLAll,:line,bins=101,centered=true)\nLPf1 = BLR.getProfile(mLf1,:line,bins=101,centered=true)\nLPf2 = BLR.getProfile(mLf2,:line,bins=101,centered=true)\nLPf3 = BLR.getProfile(mLf3,:line,bins=101,centered=true)\nLPf4 = BLR.getProfile(mLf4,:line,bins=101,centered=true)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Note that this time we don't store the profiles in their respective models (although we could!) because we are going to plot all of the models on top of each other by hand. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"To generate the average phase profile we need to pass a few bits of additional information to the phase function. As the documenation there shows, we must supply the U-V baseline information (in units of rmMlambda), the position angle, and the angular scale size of the BLR. Using the published information in the paper we can set these quantities and generate the average phase profiles like so:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"U = [-18.346909957837198, -33.56613523884647, -48.698570595903554, -14.942664391893409, -29.796334354450384, -14.76368897621181, -24.759483405776525, -32.71936044780294, -36.682578352633264, -7.76620715016356, -11.58052554955926, -4.073062007808528, -24.892849909294707, -39.75804336980509, -53.27689326473395, -14.957054767646966, -28.352905965208993, -13.459074151241555, -24.301161456982094, -38.43158347498171, -49.64708431162909, -13.168981507518257, -23.464313904842403, -10.912122036718138] #Mλ\nV = [8.63641703495584, -6.383504477240494, -27.578844897537465, -15.04195936592504, -36.26778925081391, -21.229760064196043, 9.689797323095124, -4.798395078027196, -25.56317284034309, -14.479367253742678, -35.24862063439095, -20.773150186942956, 8.946312891458865, -5.906062082484997, -26.94693584103236, -14.816925731069297, -35.8588243819711, -21.043799197907198, 9.817029995084985, -5.8946612647096215, -27.583851892747216, -15.401140293812933, -37.58326121804998, -21.630778375611328] #Mλ\nBLRAng = 8.4e7*2*2e33*6.67e-8/9e20/548/3.09e24 #rₛ in radians for BLR distance of 548 Mpc\n\nphaseAll = BLR.getProfile(mLAll,:phase,bins=101,centered=true,U=U,V=V,PA=160/180*π,BLRAng=BLRAng)\nphasef1 = BLR.getProfile(mLf1,:phase,bins=101,centered=true,U=U,V=V,PA=160/180*π,BLRAng=BLRAng)\nphasef2 = BLR.getProfile(mf2,:phase,bins=101,centered=true,U=U,V=V,PA=160/180*π,BLRAng=BLRAng)\nphasef3 = BLR.getProfile(mLf3,:phase,bins=101,centered=true,U=U,V=V,PA=160/180*π,BLRAng=BLRAng)\nphasef4 = BLR.getProfile(mLf4,:phase,bins=101,centered=true,U=U,V=V,PA=160/180*π,BLRAng=BLRAng)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"We can then plot the line and phase profiles for all the models and compare to Figure 2 in Long+2023:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"using Plots\n\npLP = plot(title=\"line profiles\",xlabel=\"Δv [Mm/s]\",ylabel=\"flux [normalized]\") #initialize LP plot\nLPList = [LPAll,LPf1,LPf2,LPf3,LPf4]\nnorm = maximum(LPAll.binSums)\nfor p in LPList\n    pLP = plot!(p.binCenters.*3e2,p.binSums./norm,label=\"\",lw=2) #label them in the phase plot only\nend\n\npPhase = plot(title=\"average phase profiles\",xlabel=\"Δv [Mm/s]\",ylabel=\"Δϕ [deg]\",legend=:topleft) #initialize phase plot\nLPList = [phaseAll,phasef1,phasef2,phasef3,phasef4]\nlabels = [\"All terms equal\",\"f₁ only\",\"f₂ only\",\"f₃ only\",\"f₄ only\"]\nfor (l,p) in zip(labels,LPList)\n    pPhase = plot!(p.binCenters.*3e2,p.binSums.*180/π,label=l,lw=2)\nend\n\nplot(pLP,pPhase,layout=@layout([a;b]),size=(500,800),margins=5*Plots.Measures.mm)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Which should return something similar to the left panel below. Compared to the original plot (right panel) we can again see that we have reproduced the result quite well. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"(Image: line and phase profiles for disk-wind models)","category":"page"},{"location":"usage_examples/#Reproducing-the-combined-model-line-and-delay-profiles-shown-in-Long2025","page":"Usage and Examples","title":"Reproducing the combined model line and delay profiles shown in Long+2025","text":"","category":"section"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"The real utility of BroadLineRegions.jl is not in its ability to model certain prescriptions for the BLR, but instead the ability to flexibly combine them. To demonstrate this we will reproduce the hybrid disk + cloud model line and delay profiles shown in Figure 4 of Long+2025. As described in the paper, this model is a combination of a Pancoast style \"cloud\" model and a simple azimuthally isotropic disk model with a bit of radial inflow. We can generate both submodels and then combine them with simple syntax: ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"mDisk = BLR.DiskWindModel(300.,40.,1.0,30/180*π,nr=512,nϕ=1024,f1=0.0,f2=0.0,f3=0.0,f4=1.0,\n        reflect=false,I=BLR.DiskWindIntensity,τ=5.,v=BLR.vCircularRadialDisk,vᵣFrac=0.33,inflow=true) \n        #setting only f4 = azimuthally isotropic disk, 2/3 Keplerian 1/3 inflow velocity field\nmClouds = BLR.cloudModel(1_000_000; I=BLR.cloudIntensity, v=BLR.vCloudTurbulentEllipticalFlow, i=30/180*π, \n        θₒ=15/180*π, β=1.25, F=0.5, μ=300., κ=0.4, ξ=0.6, γ=0.65, fEllipse=0.8, fFlow=0.0, θₑ=35/180*π, σρᵣ=0.2, \n        σρc=0.04, σΘᵣ=0.4, σΘc=0.1, σₜ=0.05,τ=0.0)\n        #parameters from Long+2025\n\n#in Long+2025 the ratio between the sum of intensity values in the cloud submodel and disksubmodel is 1:1\n#so we need to rescale one of the models to ensure this is true\n#note that scaling things this way is arbitrary -- a more physical way would be to specify the ratio of I*ΔA\nIDisk = BLR.getVariable(mDisk,:I)\nIClouds = BLR.getVariable(mClouds,:I)\nratio = sum(IDisk[.!isnan.(IDisk)])/sum(IClouds[.!isnan.(IClouds)])\nfor ring in mDisk.rings\n    ring.I .*= 1/ratio\nend\n\nmCombined = mDisk+mClouds #all we have to do to combine models is \"add\" them!","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"We can again easily generate profiles for both the combined model and the submodels. This time we will generate line and delay profiles for each component and the combined model to compare to Figure 4 of Long+2025:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"#get line profiles for each model\nLPCombined = BLR.getProfile(mCombined,:line,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)\nLPDisk = BLR.getProfile(mDisk,:line,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)\nLPClouds = BLR.getProfile(mClouds,:line,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)\n#get delay profiles for each model\nDPCombined = BLR.getProfile(mCombined,:delay,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)\nDPDisk = BLR.getProfile(mDisk,:delay,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)\nDPClouds = BLR.getProfile(mClouds,:delay,minX=-1e4/3e5,maxX=1e4/3e5,bins=101)\n\n#plot the results\nusing Plots\npLP = plot(LPCombined.binCenters.*3e5,LPCombined.binSums./maximum(LPCombined.binSums),c=:purple,lw=2,label=\"\")\npLP = plot!(LPDisk.binCenters.*3e5,LPDisk.binSums./maximum(LPDisk.binSums),c=:dodgerblue,lw=2,label=\"\",ls=:dash)\npLP = plot!(LPClouds.binCenters.*3e5,LPClouds.binSums./maximum(LPClouds.binSums),c=:crimson,lw=2,label=\"\",ls=:dash)\npLP = plot!(xlabel=\"v [km/s]\",ylabel=\"flux [normalized]\",title=\"line profiles\",xticks=[0.5e4*i for i=-2:2],xlims=(-1e4,1e4))\n\nM = 1.7e8*2e30 #kg\nrs = 2*6.67e-11*M/9e16 #2GM/c^2, m\nrsDay = rs/3e8/3600/24 #days\npDP = plot(DPCombined.binCenters.*3e5,DPCombined.binSums.*rsDay,c=:purple,lw=2,label=\"combined\")\npDP = plot!(DPDisk.binCenters.*3e5,DPDisk.binSums.*rsDay,c=:dodgerblue,lw=2,label=\"thin-disk component\",ls=:dash)\npDP = plot!(DPClouds.binCenters.*3e5,DPClouds.binSums.*rsDay,c=:crimson,lw=2,label=\"cloud component\",ls=:dash)\npDP = plot!(xlabel=\"v [km/s]\",ylabel=\"delay [days]\",title=\"delay profiles\",xticks=[0.5e4*i for i=-2:2],\n    foreground_color_legend=nothing,background_color_legend=nothing,xlims=(-1e4,1e4),ylims=(0,16))\n\nplot(pLP,pDP,layout=@layout([a;b]),size=(500,800),tickdirection=:out,minorticks=true,margins=5*Plots.Measures.mm)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Which should produce something like the left panel in the comparison below (with the right panel being the result published in Long+2025):","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"(Image: line and delay profiles for combined + submodels)","category":"page"},{"location":"usage_examples/#Defining-your-own-custom-models","page":"Usage and Examples","title":"Defining your own custom models","text":"","category":"section"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"BroadLineRegions.jl makes it easy to define your own models, either by modifying one of the existing classes of models or starting entirely from scratch. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"For example, say you wanted to use the cloudModel as a base but wanted the intensities to be completely randomized. You could define your own custom intensity function and pass that to the cloudModel constructor like so:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"myCustomIntensityFunction(;_...) = rand() #note the _... to handle unsupported kwargs that may be passed to your intensity function\nmyCloudModel = BLR.cloudModel(100,I=myCustomIntensityFunction) #100 clouds with random intensities using defaults for all other parameters","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"It is possible to pass custom intensity, velocity, response, and optical depth functions to either cloudModel or DiskWindModel.","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"If you already have some precalculated result for any of the above quantities which you would like to use in your model, you can also pass that array to the model constructor so long as it matches the size requirements (i.e. if you have 100 clouds must pass an array of 100 intensities). ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"You can also modify models after creation, as shown in the Long+2025 example above where we rescaled the total intensity in the disk submodel. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"note: Note\nThe model and ring structs are mutable, meaning any operations you perform on them overwrite previous values. This includes submodels in larger models, i.e. if you overwrite a field in a combined model the submodel struct will also be mutated. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Of course you are not limited to using BroadLineRegions.jl's predefined model constructors. The most general way to make a model is to simply pass an array of ring structs, a dictionary of profile structs, a camera struct, and an array of submodel start indices. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Each ring represents a \"ring\" on a \"camera\" observing the BLR, and this mutable structs holds all the interesting quantities about the BLR we might wish to model. The camera struct holds the alpha (x) and beta (y) camera coordinates for all points in the model, and in each corresponding ring we must supply the relevant physical information on the BLR associated with that camera pixel. See the full documentation of ring for all available options, but at a minimum in each ring we must define phi, I, v, i and r for the BLR. ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"For example, say we were looking top down at an imaginary BLR whose bespoke structure happened to spell out the friendly message \"don't panic\" with random intensities and rotating out of the page. We could implement this custom BLR like:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"# Generate a matrix with 1s for letter pixels and 0s for background\nfunction fortytwo() #Full disclosure: Claude helped write this one...\n    mat = zeros(Int, 8, 53)\n    \n    # d\n    mat[1,1] = 1; mat[1,2] = 1; mat[1,3] = 1; mat[1,4] = 1\n    mat[2,1] = 1;                                      mat[2,5] = 1\n    mat[3,1] = 1;                                      mat[3,5] = 1\n    mat[4,1] = 1;                                      mat[4,5] = 1\n    mat[5,1] = 1;                                      mat[5,5] = 1\n    mat[6,1] = 1;                                      mat[6,5] = 1\n    mat[7,1] = 1;                                      mat[7,5] = 1\n    mat[8,1] = 1; mat[8,2] = 1; mat[8,3] = 1; mat[8,4] = 1\n    \n    # o\n    mat[1,7] = 1; mat[1,8] = 1; mat[1,9] = 1; mat[1,10] = 1; mat[1,11] = 1\n    mat[2,7] = 1;                                            mat[2,11] = 1\n    mat[3,7] = 1;                                            mat[3,11] = 1\n    mat[4,7] = 1;                                            mat[4,11] = 1\n    mat[5,7] = 1;                                            mat[5,11] = 1\n    mat[6,7] = 1;                                            mat[6,11] = 1\n    mat[7,7] = 1;                                            mat[7,11] = 1\n    mat[8,7] = 1; mat[8,8] = 1; mat[8,9] = 1; mat[8,10] = 1; mat[8,11] = 1\n    \n    # n\n    mat[1,13] = 1;                                           mat[1,17] = 1\n    mat[2,13] = 1;                                           mat[2,17] = 1\n    mat[3,13] = 1; mat[3,14] = 1; mat[3,15] = 1;             mat[3,17] = 1\n    mat[4,13] = 1; mat[4,14] = 1; mat[4,15] = 1; mat[4,16] = 1; mat[4,17] = 1\n    mat[5,13] = 1;                               mat[5,16] = 1; mat[5,17] = 1\n    mat[6,13] = 1;                                           mat[6,17] = 1\n    mat[7,13] = 1;                                           mat[7,17] = 1\n    mat[8,13] = 1;                                           mat[8,17] = 1\n    \n    # ' (apostrophe)\n    mat[1,19] = 1\n    mat[2,19] = 1\n    \n    # t\n                   mat[1,22] = 1\n                   mat[2,22] = 1\n    mat[3,21] = 1; mat[3,22] = 1; mat[3,23] = 1; mat[3,24] = 1; mat[3,25] = 1\n    mat[4,21] = 1; mat[4,22] = 1; mat[4,23] = 1; mat[4,24] = 1; mat[4,25] = 1\n                   mat[5,22] = 1\n                   mat[6,22] = 1\n                   mat[7,22] = 1;                                           mat[7,25] = 1\n                   mat[8,22] = 1; mat[8,22] = 1; mat[8,23] = 1; mat[8,24] = 1\n\n    # space between t and p\n    \n    # p\n    mat[1,29] = 1; mat[1,30] = 1; mat[1,31] = 1; mat[1,32] = 1; mat[1,33] = 1\n    mat[2,29] = 1;                                           mat[2,33] = 1\n    mat[3,29] = 1;                                           mat[3,33] = 1\n    mat[4,29] = 1; mat[4,30] = 1; mat[4,31] = 1; mat[4,32] = 1; mat[4,33] = 1\n    mat[5,29] = 1\n    mat[6,29] = 1\n    mat[7,29] = 1\n    mat[8,29] = 1\n    \n    # a\n    mat[1,35] = 1; mat[1,36] = 1; mat[1,37] = 1; mat[1,38] = 1; mat[1,39] = 1\n    mat[2,35] = 1;                                           mat[2,39] = 1\n    mat[3,35] = 1;                                           mat[3,39] = 1\n    mat[4,35] = 1; mat[4,36] = 1; mat[4,37] = 1; mat[4,38] = 1; mat[4,39] = 1\n    mat[5,35] = 1; mat[5,36] = 1; mat[5,37] = 1; mat[5,38] = 1; mat[5,39] = 1\n    mat[6,35] = 1;                                           mat[6,39] = 1\n    mat[7,35] = 1;                                           mat[7,39] = 1\n    mat[8,35] = 1;                                           mat[8,39] = 1\n    \n    # n\n    mat[1,41] = 1;                                           mat[1,45] = 1\n    mat[2,41] = 1;                                           mat[2,45] = 1\n    mat[3,41] = 1; mat[3,42] = 1; mat[3,43] = 1;             mat[3,45] = 1\n    mat[4,41] = 1; mat[4,42] = 1; mat[4,43] = 1; mat[4,44] = 1; mat[4,45] = 1\n    mat[5,41] = 1;                               mat[5,44] = 1; mat[5,45] = 1\n    mat[6,41] = 1;                                           mat[6,45] = 1\n    mat[7,41] = 1;                                           mat[7,45] = 1\n    mat[8,41] = 1;                                           mat[8,45] = 1\n    \n    # i\n    mat[1,47] = 1\n    mat[3,47] = 1\n    mat[4,47] = 1\n    mat[5,47] = 1\n    mat[6,47] = 1\n    mat[7,47] = 1\n    mat[8,47] = 1\n    \n    # c\n    mat[1,49] = 1; mat[1,50] = 1; mat[1,51] = 1; mat[1,52] = 1; mat[1,53] = 1\n    mat[2,49] = 1\n    mat[3,49] = 1\n    mat[4,49] = 1\n    mat[5,49] = 1\n    mat[6,49] = 1\n    mat[7,49] = 1\n    mat[8,49] = 1; mat[8,50] = 1; mat[8,51] = 1; mat[8,52] = 1; mat[8,53] = 1\n    \n    return mat\nend\n\nmat = reverse(fortytwo(),dims=1) #reverse top/bottom\nα = zeros(sum(mat)) #camera x coordinates in units of rs\nβ = zeros(sum(mat)) #camera y coordinates in units of rs\nαj = range(-size(mat)[2]/2,stop=size(mat)[2]/2,length=size(mat)[2])\nβi = range(-size(mat)[1]/2,stop=size(mat)[1]/2,length=size(mat)[1])\ncounter = 0\nfor i=1:size(mat)[1]\n    for j=1:size(mat)[2]\n        if mat[i,j] != 0 #fill in camera coordinates where matrix non-empty\n            counter += 1 #which point are we on?\n            α[counter] = αj[j]\n            β[counter] = βi[i]\n        end\n    end\nend\n\ncam = BLR.camera(α,β,false) #initialize the camera for the model, set raytraced flag to false\n\nrings = Array{BLR.ring}(undef,sum(mat)) #initialize array of rings\n\nfor j=1:length(rings) #define the rings with minimum physical quantities of our model BLR\n    r = √(α[j]^2+β[j]^2) #radius in physical space = camera radius for i = 0.0\n    ϕ = atan(β[j],α[j]) #angle in physical space = camera ngle for i = 0.0\n    i = 0.0 #inclination\n    I = rand()\n    v = sqrt(1/r)*sign(α[j]) #rotating in/out of the page and proportional to √1/r\n    ΔA = 1.0 #rₛ²\n    rings[j] = BLR.ring(r=r,ϕ=ϕ,i=i,I=I,v=v,ΔA=ΔA) #define ring with minimum physical quantities using defaults for everything else\n    #note that 3d plotting will be wrong for this, as the 3D plotting routine assumes you start with point in x-y plane and then rotate into z direction\n    #do things in this order if you care about 3d visualizations of your custom models (but otherwise it does not matter)\nend\n\n# Create the custom BLR model\nmyCustomModel = BLR.model(rings,Dict{Symbol,BLR.profile}(),cam,[1]) #no profiles (yet), only one submodel so subModelStartInds = [1] \n\n#visualize it\nusing Plots\nimgI = BLR.image(myCustomModel,:I,markersize=2.,background_color=:black,cmap=cgrad([:red,:lime],[0.0,0.3,1.0]))\nimgv = BLR.image(myCustomModel,:v,markersize=2.,background_color=:black,cmap=cgrad([:blue,:red],[-1.,0.,1.]))\np = BLR.getProfile(myCustomModel,:line,bins=10)\nBLR.setProfile!(myCustomModel,p)\np = BLR.getProfile(myCustomModel,:r,bins=10)\nBLR.setProfile!(myCustomModel,p)\np = BLR.getProfile(myCustomModel,:ϕ,bins=10)\nBLR.setProfile!(myCustomModel,p)\nP = BLR.profile(myCustomModel)\nplot(imgI,imgv,P,layout=@layout([grid(2,1) P{0.4w}]),size=(800,400),margins=5*Plots.Measures.mm)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Which produces the following plot: (Image: don't panic BLR)","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"note: Note\nIf you want the default 3D visualizations to work correctly, define your points in the x-y plane and then rotate them into 3D space using rotate3D as this is what plot3d calls on points to make the 3D visualizations. This should not affect any science use case if you opt to initialize the points some other way (like in the quick example above).","category":"page"},{"location":"usage_examples/#Additional-(selected)-helpful-tools-from-the-[API](@ref)-not-described-above","page":"Usage and Examples","title":"Additional (selected) helpful tools from the API not described above","text":"","category":"section"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"After combining submodels, access their constituent parts by simply writing:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"mCombined = m1+m2 #combine two models\nm1 = mCombined[1]; m2 = mCombined[2] #get access to the submodels with indexing ","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"If you are annoyed with the output statements after things, suppress them by placing a semicolon after:","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"mCombined; #suppresses output","category":"page"},{"location":"usage_examples/","page":"Usage and Examples","title":"Usage and Examples","text":"Other functions: ","category":"page"},{"location":"usage_examples/#BroadLineRegions.getVariable","page":"Usage and Examples","title":"BroadLineRegions.getVariable","text":"getVariable(m::model, variable::Union{String,Symbol,Function}; flatten=false)\n\nRetrieve elements from model object and stack them into matrices for easy manipulation.\n\nArguments\n\nm::model: Model object to extract variables from\nvariable::Union{String,Symbol,Function}: Variable to extract from model\nIf String, will be converted to Symbol\nMust be a valid attribute of model.rings (e.g. :I, :v, :r, :e, :i, :ϕ) or a function that can be applied to model.rings\nExample: Keplerian disk time delays could be calculated like t(ring) = ring.r*(1 .+ sin.(ring.ϕ).*ring.i))\nflatten::Bool=false: If true, flatten the result to a vector\n\nReturns\n\nArray{Float64,}: Matrix or vector of extracted variable from model.rings, created by stacking the output variable for each ring\nFor example, if variable given is :I, result will have shape (length(r), length(ϕ)) as at each r and ϕ there is a value of I\nIf flatten=true, result will be a flattened vector\n\n\n\n\n\ngetVariable(m::model, variable::Symbol; flatten=false)\n\nRetrieve model variable when specified as a Symbol. See main docstring for details.\n\n\n\n\n\ngetVariable(m::model, variable::Function; flatten=false)\n\nRetrieve model variable when specified as a Function. See main docstring for details.\n\n\n\n\n\n","category":"function"},{"location":"usage_examples/#BroadLineRegions.raytrace!","page":"Usage and Examples","title":"BroadLineRegions.raytrace!","text":"raytrace!(m::model; IRatios::Union{Float64,Array{Float64,}}=1.0, \n        τCutOff::Float64=1.0, raytraceFreeClouds::Bool=false)\n\nPerform raytracing for a model, combining overlapping components along line of sight.\n\nwarning: Slow\nThis function not very performant and can take a long time to combine large models. Consider using removeDiskObscuredClouds! for simple disk obscuration removal if you do not need full raytracing.\n\nThis function should be called after combining all relevant models (i.e. mCombined = m1 + m2 + m3...). It performs raytracing in discrete steps (no absorption, only adding intensity in chunks along  the line of sight until maximum optical depth τ is reached) and generates a new model object  with extraneous points removed. Note that this function will mutate the input model objects.\n\nArguments\n\nm::model: Model to raytrace\nIRatios::Union{Float64,Array{Float64,}}=1.0: Intensity ratios for each submodel\nIf Float64, applies to all submodels equally\nIf array, applies to each submodel individually (must match number of submodels)\nUsed when combining models with different intensity functions if they aren't properly normalized\nτCutOff::Float64=1.0: Maximum optical depth to raytrace to (stops when τ > τCutOff)\nraytraceFreeClouds::Bool=false: Whether to raytrace free clouds (cloud-cloud raytracing)\nIf false, clouds are only raytraced if they overlap with a continuous model\nIf true, clouds will be checked for overlap with other clouds and raytraced accordingly\n\nReturns\n\nm::model: Model with raytraced points\n\n\n\n\n\n","category":"function"},{"location":"usage_examples/#BroadLineRegions.reset!","page":"Usage and Examples","title":"BroadLineRegions.reset!","text":"reset!(m::model; profiles=true, img=false)\n\nErase existing profiles/raytrace status.\n\nParameters\n\nm::model: Model object to reset\nprofiles::Bool=true: If true, reset profiles\nimg::Bool=false: If true, reset raytracing boolean (does not change existing model but allows model to be raytraced again after combining other new models)\n\n\n\n\n\n","category":"function"},{"location":"usage_examples/#BroadLineRegions.phase","page":"Usage and Examples","title":"BroadLineRegions.phase","text":"phase(m::model; U, V, PA, BLRAng, returnAvg=false, offAxisInds=nothing, kwargs...)\n\nCalculate differential phase signal for a model based on specified baselines, model orientation, and BLR angular size.\n\nArguments\n\nm::model: Model object to calculate phase for\nU::Vector{Float64}: U component of complex visibility in [Mλ]\nV::Vector{Float64}: V component of complex visibility in [Mλ]\nPA::Float64: On-sky position angle of the model in radians\nBLRAng::Float64: Characteristic size of the BLR model in radians (conversion from r_s to radians)\nreturnAvg::Bool=false: If true, returns the average phase across all baselines\noffAxisInds::Union{Nothing,Vector{Int}}=nothing: If provided, only calculates phase for baselines at specified indices\n\nReturns\n\nIf returnAvg=true: Tuple{Vector{Float64},Vector{Float64},Vector{Float64}} containing:\nBin edges for velocity\nBin centers for velocity\nAverage differential phase (in radians)\nIf returnAvg=false: Vector{Tuple{Vector{Float64},Vector{Float64},Vector{Float64}}} containing:\nFor each baseline, a tuple of bin edges, bin centers, and differential phase\n\nThe differential phase is calculated by integrating the phase over the model at each velocity bin, weighted by the intensity and area of each ring element.\n\n\n\n\n\n","category":"function"},{"location":"usage_examples/#BroadLineRegions.DRW","page":"Usage and Examples","title":"BroadLineRegions.DRW","text":"function DRW(;t::Array{Float64}=collect(range(0,stop=100,length=1001)), μ::Float64=0.0, τ::Float64=1.0, σ::Float64=0.1)\n\nGenerate a damped random walk continuum lightcurve following MacLeod+2010\n\nArguments:\n\nt::Vector{Float64}`: time array that returned lightcurve will be sampled at\nμ::Float64: mean value of random walk\nτ::Float64: characteristic time scale of random walk\nσ::Float64: standard deviation of random walk\n\nReturns:\n\nC::Vector{Float64}: damped random walk array corresponding to times t\n\n\n\n\n\n","category":"function"},{"location":"usage_examples/#BroadLineRegions.syntheticLC","page":"Usage and Examples","title":"BroadLineRegions.syntheticLC","text":"function syntheticLC(Ct,CLC,Ψτ;tStart=0.0,normalize=false)\n\nGenerate a synthetic lightcurve from a continuum lightcurve and a 1D transfer function.\n\nArguments:\n\nCt::Vector{Float64}: time array for the continuum lightcurve\nCLC::Vector{Float64}: continuum lightcurve values at times Ct\nΨτ::Vector{Float64}: transfer function values at times Ct\ntStart::Float64: time after which the lightcurve should be normalized to zero\nnormalize::Bool: whether to normalize the lightcurve to the extent of variations in the continuum\n\nReturns:\n\nΔlc::Vector{Float64}: synthetic lightcurve sampled at times Ct with zero point ~at tStart and optionally normalized\n\n\n\n\n\n","category":"function"},{"location":"#BroadLineRegions.jl","page":"Home","title":"BroadLineRegions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A fast and flexible toolkit for modeling the broad-line region (BLR) in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Julia","page":"Home","title":"Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"BroadLineRegions.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or install from the GitHub repo directly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/kirklong/BroadLineRegions.jl\")","category":"page"},{"location":"#Python","page":"Home","title":"Python","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To access BroadLineRegions.jl from within your Python installation, first you must install JuliaCall After successfully installing JuliaCall you can add BroadLineRegions.jl to your new Julia installation in Python with: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"from juliacall import Main as jl\nfrom juliacall import Pkg as jlPkg\njlPkg.add(\"BroadLineRegions.jl\") #or use the github link","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While this code is designed to be very flexible and modular such that you can implement your own bespoke models of the BLR easier, two popular models of the BLR are included as default models which one can play with. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To generate a \"cloud\" model similar to that of Pancoast+ 2011 and 2014, use syntax like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BroadLineRegions #exports itself as both BroadLineRegions and the shorter acronym BLR\nmClouds = BLR.cloudModel(100_000,μ=500.,β=1.,F=0.5,θₒ=30/180*π,γ=1.,ξ=1.,i=0.,\n        I=BLR.IsotropicIntensity,v=BLR.vCircularCloud,rescale=1e-5,τ=0.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To generate a \"disk-wind\" model similar to that of Chiang and Murray 1996 and 1997 following the prescription laid out in Long+ 2023 and 2025 use syntax like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mDisk = BLR.DiskWindModel(500.,5.,1.,30/180*π,nr=24,nϕ=48,scale=:log,\n        f1=1.0,f2=1.0,f3=1.0,f4=1.0,reflect=false,τ=5.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can of course define fully custom models by passing your own \"rings\" (on a camera) and optionally any default profiles, a camera struct, and submodel start indices:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mCustom = BLR.model(myCustomRings,nothing,myCustomCamera,[1]) #a custom model with no profiles, a user-defined camera for raytracing/visualization, and with no submodels","category":"page"},{"location":"","page":"Home","title":"Home","text":"Models can be combined simply by writing mCombined = m1 + m2. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generate profiles (i.e. line, phase, delay, or whatever else your heart desires) for models with syntax like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = BLR.getProfile(m,:line) #generate line profile with default parameters\nBLR.setProfile!(m,p) #optinally store the profile in model data structure ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A few default visualization recipes exist as well:","category":"page"},{"location":"","page":"Home","title":"Home","text":"profiles = BLR.profile(m) #plot all of the model's stored profiles \nimg = BLR.image(m,:I) #make an image of the model intensity, can pass any other parameter as well to \"image\" them\ngeometry = BLR.plot3d(m) #visualize the geometry of the system in a 3d plot, can also color points according to any parameter","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that no functions are exported by default into the global namespace to prevent overlap with other modules, and you must prepend the module name to all methods to access them. BroadLineRegions.jl exports itself as both BroadLineRegions and BLR, so both of these prefixes are equivalent, i.e. BroadLineRegions.model == BLR.model. If adding this prefix annoys you, you can avoid this by specifying the functions you want added to the global namespace in your import/Using statement. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BLR: DiskWindModel, cloudModel\nmDisk = DiskWindModel(parms...) #instead of BLR.DiskWindModel","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailed examples, see the Usage and Examples page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Full documentation is available in the API section.","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find this code useful in your work, please cite it as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"lorem ipsum","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you would like to contribute to the package, please open a pull request on the GitHub. For bug reports and feature requests, please open an issue on the GitHub. ","category":"page"}]
}
